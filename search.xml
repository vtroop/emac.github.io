<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[面向开发的测试技术（一）：Mock]]></title>
      <url>http://emacoo.cn/arch/test-mock/</url>
      <content type="html"><![CDATA[<blockquote>
<p>引子：自上世纪末Kent Beck提出<a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="external">TDD(Test-Driven Development)</a>开发理念以来，开发和测试的边界变的越来越模糊，从原本上下游的依赖关系，逐步演变成你中有我、我中有你的互赖关系，甚至很多公司设立了新的QE(Quality Engineer)职位。和传统的QA(Quality Assurance)不同，QE的主要职责是通过工程化的手段保证项目质量，这些手段包括但不仅限于编写单元测试、集成测试，搭建自动化测试流程，设计性能测试等。可以说，QE身上兼具了QA的质量意识和开发的工程能力。从这篇开始，我会从开发的角度分三期聊聊QE这个亦测试亦开发的角色所需的基本技能。</p>
</blockquote>
<h2 id="1-什么是Mock？"><a href="#1-什么是Mock？" class="headerlink" title="1 什么是Mock？"></a>1 什么是Mock？</h2><p>在软件测试领域，Mock的意思是模拟，简单来说，就是通过某种技术手段模拟测试对象的行为，返回预先设计的结果。这里的关键词是<strong>预先设计</strong>，也就是说对于任意被测试的对象，可以根据具体测试场景的需要，返回特定的结果。打个比方，就像BBC纪录片里面的假企鹅，可以根据拍摄需要作出不同的反应。</p>
<h2 id="2-Mock有什么用？"><a href="#2-Mock有什么用？" class="headerlink" title="2 Mock有什么用？"></a>2 Mock有什么用？</h2><p>理解了什么是Mock，再来看Mock有哪些用途。首先，Mock可以用来解除测试对象对外部服务的依赖（比如数据库，第三方接口等），使得测试用例可以<strong>独立运行</strong>。不管是传统的单体应用，还是现在流行的微服务，这点都特别重要，因为任何外部依赖的存在都会极大的限制测试用例的可迁移性和稳定性。可迁移性是指，如果要在一个新的测试环境中运行相同的测试用例，那么除了要保证测试对象自身能够正常运行，还要保证所有依赖的外部服务也能够被正常调用。稳定性是指，如果外部服务不可用，那么测试用例也可能会失败。通过Mock去除外部依赖之后，不管是测试用例的可迁移性还是稳定性，都能够上一个台阶。</p>
<p><img src="standalone.png" alt=""></p>
<p>Mock的第二个好处是替换外部服务调用，<strong>提升测试用例的运行速度</strong>。任何外部服务调用至少是跨进程级别的消耗，甚至是跨系统、跨网络的消耗，而Mock可以把消耗降低到进程内。比如原来一次秒级的网络请求，通过Mock可以降至毫秒级，整整3个数量级的差别。</p>
<p>Mock的第三个好处是<strong>提升测试效率</strong>。这里说的测试效率有两层含义。第一层含义是单位时间运行的测试用例数，这是运行速度提升带来的直接好处。而第二层含义是一个QE单位时间创建的测试用例数。如何理解这第二层含义呢？以单体应用为例，随着业务复杂度的上升，为了运行一个测试用例可能需要准备很多测试数据，与此同时还要尽量保证多个测试用例之间的测试数据互不干扰。为了做到这一点，QE往往需要花费大量的时间来维护一套可运行的测试数据。有了Mock之后，由于去除了测试用例之间共享的数据库依赖，QE就可以针对每一个或者每一组测试用例设计一套独立的测试数据，从而很容易的做到不同测试用例之间的数据隔离性。而对于微服务，由于一个微服务可能级联依赖很多其他的微服务，运行一个测试用例甚至需要跨系统准备一套测试数据，如果没有Mock，基本上可以说是不可能的。因此，不管是单体应用还是微服务，有了Mock之后，QE就可以省去大量的准备测试数据的时间，专注于测试用例本身，自然也就提升了单人的测试效率。</p>
<h2 id="3-如何Mock？"><a href="#3-如何Mock？" class="headerlink" title="3 如何Mock？"></a>3 如何Mock？</h2><p>说了这么多Mock的好处，那么究竟如何在测试中使用Mock呢？针对不同的测试场景，可以选择不同的Mock框架。</p>
<h3 id="3-1-Mockito"><a href="#3-1-Mockito" class="headerlink" title="3.1 Mockito"></a>3.1 Mockito</h3><p>如果测试对象是一个方法，尤其是涉及数据库操作的方法，那么<a href="http://site.mockito.org/" target="_blank" rel="external">Mockito</a>可能是最好的选择。作为使用最广泛的Mock框架，Mockito出于<a href="http://easymock.org/" target="_blank" rel="external">EasyMock</a>而胜于EasyMock，乃至被默认集成进Spring Testing。其实现原理是，通过CGLib在运行时为每一个被Mock的类或者对象动态生成一个<strong>代理对象</strong>，返回<strong>预先设计</strong>的结果。集成Mockito的基本步骤是：</p>
<ol>
<li>标记被Mock的类或者对象，生成代理对象</li>
<li>通过Mockito API定制代理对象的行为</li>
<li>调用代理对象的方法，获得预先设计的结果</li>
</ol>
<p>下面是我GitHub上的<a href="https://github.com/emac/spring-boot-features-demo" target="_blank" rel="external">示例工程</a>里的一个例子，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignonServiceTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 测试对象，一个服务类</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> SignonService signonService;</div><div class="line"></div><div class="line">    <span class="comment">// 被Mock的类，被服务类所依赖的一个DAO类</span></div><div class="line">    <span class="meta">@MockBean</span></div><div class="line">    <span class="keyword">private</span> SignonDao dao;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// SignonService#findAll()内部会调用SignonDao#findAll()</span></div><div class="line">        <span class="comment">// 如果不做定制，所有被Mock的类默认返回空</span></div><div class="line">        List&lt;Signon&gt; signons = signonService.findAll();</div><div class="line">        assertTrue(CollectionUtils.isEmpty(signons));</div><div class="line"></div><div class="line">        <span class="comment">// 定制返回结果</span></div><div class="line">        Signon signon = <span class="keyword">new</span> Signon();</div><div class="line">        signon.setUsername(<span class="string">"foo"</span>);</div><div class="line">        when(dao.findAll()).thenReturn(Lists.newArrayList(signon));</div><div class="line"></div><div class="line">        signons = signonService.findAll();</div><div class="line">        <span class="comment">// 验证返回结果和预先设计的结果一致</span></div><div class="line">        assertEquals(<span class="number">1</span>, signons.size());</div><div class="line">        assertEquals(<span class="string">"foo"</span>, signons.get(<span class="number">0</span>).getUsername());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的测试用例可以看到，通过Mock服务类所依赖的DAO类，我们可以跳过所有的数据库操作，任意定制返回结果，从而专注于测试服务类内部的业务逻辑。这是传统的非Mock测试所难以实现的。</p>
<p><em>注意：Mockito不支持Mock私有方法或者静态方法，如果要Mock这类方法，可以使用<a href="https://github.com/powermock/powermock" target="_blank" rel="external">PowerMock</a>。</em></p>
<h3 id="3-2-WireMock"><a href="#3-2-WireMock" class="headerlink" title="3.2 WireMock"></a>3.2 WireMock</h3><p>如果说Mocketo是瑞士军刀，可以Mock Everything，那么<a href="http://wiremock.org/" target="_blank" rel="external">WireMock</a>就是为微服务而生的倚天剑。和处在对象层的Mockito不同，WireMock针对的是<strong>API</strong>。假设有两个微服务，Service-A和Service-B，Service-A里的一个API（姑且称为API-1），依赖于Service-B，那么使用传统的测试方法，测试API-1时必然需要同时启动Service-B。如果使用WireMock，那么就可以<strong>在Service-A端</strong>Mock所有依赖的Service-B的API，从而去掉Service-B这个外部依赖。</p>
<p>同样看一个我GitHub上的<a href="https://github.com/emac/spring-boot-features-demo" target="_blank" rel="external">示例工程</a>里的一个例子，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@WebMvcTest</span>(VacationController.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VacationControllerTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Mock被依赖的另一个微服务</span></div><div class="line">    <span class="meta">@Rule</span></div><div class="line">    <span class="keyword">public</span> WireMockRule wireMockRule = <span class="keyword">new</span> WireMockRule(<span class="number">3001</span>);</div><div class="line">    </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> MockMvc mockMvc;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</div><div class="line">        <span class="comment">// 定制返回结果</span></div><div class="line">        JsonResult&lt;Boolean&gt; expected = JsonResult.ok(<span class="keyword">true</span>);</div><div class="line">        stubFor(get(urlPathEqualTo(<span class="string">"/api/vacation/isWeekend"</span>))</div><div class="line">                .willReturn(aResponse()</div><div class="line">                        .withStatus(OK.value())</div><div class="line">                        .withHeader(CONTENT_TYPE, APPLICATION_JSON_UTF8_VALUE)</div><div class="line">                        .withBody(objectMapper.writeValueAsString(expected))));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsWeekendProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 构造请求参数</span></div><div class="line">        VacationRequest request = <span class="keyword">new</span> VacationRequest();</div><div class="line">        request.setType(PERSONAL);</div><div class="line">        OffsetDateTime lastSunday = OffsetDateTime.now().with(TemporalAdjusters.previous(SUNDAY));</div><div class="line">        request.setStart(lastSunday);</div><div class="line">        request.setEnd(lastSunday.plusDays(<span class="number">1</span>));</div><div class="line"></div><div class="line">        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(<span class="string">"/vacation/isWeekend"</span>);</div><div class="line">        request.toMap().forEach((k, v) -&gt; builder.param(k, v));</div><div class="line">        JsonResult&lt;Boolean&gt; expected = JsonResult.ok(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        mockMvc.perform(builder)</div><div class="line">                <span class="comment">// 验证返回结果和预先设计的结果一致</span></div><div class="line">                .andExpect(status().isOk())</div><div class="line">                .andExpect(content().contentType(APPLICATION_JSON_UTF8))</div><div class="line">                .andExpect(content().string(objectMapper.writeValueAsString(expected)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和Mockito类似，在测试用例中集成WireMock的基本步骤是：</p>
<ol>
<li>声明代理服务，以替代被Mock的微服务</li>
<li>通过WireMock API定制代理服务的返回结果</li>
<li>调用代理服务，获得预先设计的结果</li>
</ol>
<p>值得一提的是，除了API方式的集成，WireMock还支持以Jar包的形式独立运行，从配置文件中加载预先设计的响应结果，以替代被Mock的微服务。更多信息可以参阅<a href="http://wiremock.org/docs/" target="_blank" rel="external">官方文档</a>。</p>
<p>其他类似的Mock API的框架还有OkHttp的<a href="https://github.com/square/okhttp/tree/master/mockwebserver" target="_blank" rel="external">mockwebserver</a>，<a href="https://github.com/dreamhead/moco" target="_blank" rel="external">moco</a>和<a href="http://www.mock-server.com/" target="_blank" rel="external">mockserver</a>。mockwebserver也属于嵌入式Mock框架的范畴，但功能过于简单。moco，mockserver虽然功能完善，但需要独立部署，和WireMock相比不具有优势。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>以上就是我对Mock技术的一些见解，欢迎你到我的<a href="https://github.com/emac/emac.github.io/issues/2" target="_blank" rel="external">留言板</a>分享，和大家一起过过招。最后还要说一句，Mock技术虽然强大，但主要还是适用于单元测试，在集成测试，性能测试，自动化测试等其他测试领域使用并不多。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><ul>
<li><a href="https://www.linkedin.com/pulse/moving-from-quality-assurance-engineering-brief-history-nitin-mehra" target="_blank" rel="external">Moving from Quality Assurance to Quality Engineering. A brief history in time and what lies ahead.</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】详解Spring MVC中不同格式的POST请求参数的数据类型转换过程]]></title>
      <url>http://emacoo.cn/backend/spring-converter/</url>
      <content type="html"><![CDATA[<blockquote>
<p>你也许写过很多Controller，那你可曾和我一样好奇最初字符串格式的HTTP请求参数如何转化成类型各异的Controller方法参数？</p>
</blockquote>
<p>引子：假设现在有一个Long型的请求参数，需要转化为OffsetDateTime类型的方法参数，请问如何实现？</p>
<h2 id="1-常见的POST请求格式"><a href="#1-常见的POST请求格式" class="headerlink" title="1 常见的POST请求格式"></a>1 常见的POST请求格式</h2><p>首先，让我们看一下3种常见的POST请求格式：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code>: 默认的表单提交格式，不支持文件</li>
<li><code>multipart/form-data</code>: 用于上传文件，同时也支持普通类型的参数</li>
<li><code>application/json</code>: 提交JSON格式的raw数据，适用于AJAX请求和REST风格的接口</li>
</ul>
<p>对于不同类型的请求格式，Spring有着不同的转换过程（从请求参数到方法参数），请看下图。</p>
<h2 id="2-Spring-MVC中的数据类型转换过程"><a href="#2-Spring-MVC中的数据类型转换过程" class="headerlink" title="2 Spring MVC中的数据类型转换过程"></a>2 Spring MVC中的数据类型转换过程</h2><p><img src="spring-converter.png" alt=""></p>
<p>从上图可以看到，Spring在解析请求参数时，会根据请求格式进入到不同的转换流程：</p>
<ul>
<li>如果是<strong>非raw请求</strong>（即包含参数数组），则交由ModelAttributeMethodProcessor处理，ModelAttributeMethodProcessor再调用Spring Converter SPI对请求参数逐个进行转换。</li>
<li>如果是<strong>raw请求</strong>，则交由RequestResponseBodyMethodProcessor处理，对于JSON格式的请求体，会再调用MappingJackson2HttpMessageConverter，最终通过ObjectMapper完成转换。</li>
</ul>
<p><i>*关于Spring Converter SPI的进一步解读，可参考<a href="http://jinnianshilongnian.iteye.com/blog/1723270" target="_blank" rel="external">这篇文章</a></i></p>
<p>回到开头的那个问题，答案就很简单了。如果是非raw请求，则需要实现一个自定义的Long-&gt;OffsetDatetime的Converter；如果是raw请求，则确保ObjectMapper中包含一个Long-&gt;OffsetDatetime的反序列化器，注册Jackon自带的JavaTimeModule即可。</p>
<h3 id="2-1-如何注册自定义Converter？"><a href="#2-1-如何注册自定义Converter？" class="headerlink" title="2.1 如何注册自定义Converter？"></a>2.1 如何注册自定义Converter？</h3><p>以Spring Boot为例，</p>
<p>1. 实现<code>org.springframework.core.convert.converter.Converter</code>接口生成一个自定义Converter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class OffsetDateTimeConverter implements Converter&lt;String, OffsetDateTime&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public OffsetDateTime convert(String source) &#123;</div><div class="line">        if (!NumberUtils.isNumber(source)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Long milli = NumberUtils.createLong(source);</div><div class="line">        return OffsetDateTime.ofInstant(Instant.ofEpochMilli(milli), systemDefault());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2. 选择一个标注@Configuration注解的配置类，继承<code>org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter</code>，然后覆盖addFormatters方法，注册自定义Converter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class WebConfig extends WebMvcConfigurerAdapter &#123;</div><div class="line">	@Override</div><div class="line">    public void addFormatters(FormatterRegistry registry) &#123;</div><div class="line">        registry.addConverter(new OffsetDateTimeConverter());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-如何注册自定义Jackson-Deserializer和Serializer？"><a href="#2-2-如何注册自定义Jackson-Deserializer和Serializer？" class="headerlink" title="2.2 如何注册自定义Jackson Deserializer和Serializer？"></a>2.2 如何注册自定义Jackson Deserializer和Serializer？</h3><p>以Spring Boot为例，</p>
<p>1. 继承<code>com.fasterxml.jackson.databind.JsonDeserializer</code>和<code>com.fasterxml.jackson.databind.JsonSerializer</code>生成自定义Jackson Deserializer和Serializer。</p>
<p>2. 继承<code>com.fasterxml.jackson.databind.module.SimpleModule</code>生成一个自定义Jackson Module，在其中添加自定义的Jackson Deserializer和Serializer。</p>
<p>3. 选择一个标注@Configuration注解的配置类，通过@Bean注解将自定义的Jackson Module注册为Bean，Spring Boot会自动发现和注册这个Module到默认的ObjectMapper中。</p>
<p>示例代码参见下一小节。</p>
<h2 id="3-更多示例"><a href="#3-更多示例" class="headerlink" title="3 更多示例"></a>3 更多示例</h2><h3 id="3-1-演示Controller"><a href="#3-1-演示Controller" class="headerlink" title="3.1 演示Controller"></a>3.1 演示Controller</h3><blockquote>
<p>演示3种常见的GET, POST请求参数的数据类型转换。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Validated</div><div class="line">public class VacationController implements IController &#123;</div><div class="line"></div><div class="line">    private static final List&lt;DayOfWeek&gt; WEEKENDS = Lists.newArrayList(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 转换GET请求参数</div><div class="line">     */</div><div class="line">    @RequestMapping(value = &quot;/isWeekend&quot;, method = RequestMethod.GET)</div><div class="line">    public JsonResult&lt;Boolean&gt; isWeekend(@Valid VacationRequest request) &#123;</div><div class="line">        return JsonResult.ok(WEEKENDS.contains(request.getStart().getDayOfWeek()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 转换POST请求体</div><div class="line">     */</div><div class="line">    @RequestMapping(value = &quot;/approve&quot;, method = RequestMethod.POST)</div><div class="line">    public JsonResult&lt;VacationApproval&gt; vacate(@RequestBody @Valid VacationRequest request) &#123;</div><div class="line">        return JsonResult.ok(VacationApproval.approve(request));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 转换POST请求参数</div><div class="line">     */</div><div class="line">    @RequestMapping(value = &quot;/deny&quot;, method = RequestMethod.POST)</div><div class="line">    public JsonResult&lt;VacationApproval&gt; deny(@Valid VacationRequest request) &#123;</div><div class="line">        return JsonResult.ok(VacationApproval.deny(request));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-自定义Enum-Converter（用于非raw格式的请求）"><a href="#3-2-自定义Enum-Converter（用于非raw格式的请求）" class="headerlink" title="3.2 自定义Enum Converter（用于非raw格式的请求）"></a>3.2 自定义Enum Converter（用于非raw格式的请求）</h3><blockquote>
<p>基于特定属性的枚举数据类型转换器，如果无法找到，再尝试用枚举名进行转换。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static class CustomEnumConverter&lt;T extends Enum&lt;T&gt;&gt; implements Converter&lt;String, T&gt; &#123;</div><div class="line"></div><div class="line">    private Class&lt;T&gt; enumCls;</div><div class="line">    private String prop;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param enumCls 枚举类型</div><div class="line">     * @param prop 属性名</div><div class="line">     */</div><div class="line">    public CustomEnumConverter(Class&lt;T&gt; enumCls, String prop) &#123;</div><div class="line">        this.enumCls = enumCls;</div><div class="line">        this.prop = prop;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public T convert(String source) &#123;</div><div class="line">        if (StringUtils.isEmpty(source)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        return Enums.getEnum(enumCls, prop, source).orElseGet(() -&gt;</div><div class="line">                Stream.of(enumCls.getEnumConstants())</div><div class="line">                        .filter(e -&gt; e.name().equals(source))</div><div class="line">                        .findFirst().orElse(null)</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-自定义Module（用于raw格式的请求）"><a href="#3-3-自定义Module（用于raw格式的请求）" class="headerlink" title="3.3 自定义Module（用于raw格式的请求）"></a>3.3 自定义Module（用于raw格式的请求）</h3><blockquote>
<p>用于注册自定义Enum Serializer和Enum Deserializer。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CustomEnumModule extends SimpleModule &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param prop 属性名</div><div class="line">     */</div><div class="line">    public CustomEnumModule(@NotNull String prop)&#123;</div><div class="line">        Asserts.notBlank(prop);</div><div class="line"></div><div class="line">        addDeserializer(Enum.class, new CustomEnumDeserializer(prop));</div><div class="line">        addSerializer(Enum.class, new CustomEnumSerializer(prop));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-1-自定义Enum-Serializer"><a href="#3-3-1-自定义Enum-Serializer" class="headerlink" title="3.3.1 自定义Enum Serializer"></a>3.3.1 自定义Enum Serializer</h4><blockquote>
<p>自定义枚举序列化器，查找特定属性并进行序列化，如果无法找到，则序列化为枚举名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Slf4j</div><div class="line">public class CustomEnumSerializer extends JsonSerializer&lt;Enum&gt; &#123;</div><div class="line"></div><div class="line">    private String prop;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param prop 属性名</div><div class="line">     */</div><div class="line">    public CustomEnumSerializer(@NotNull String prop) &#123;</div><div class="line">        Asserts.notBlank(prop);</div><div class="line"></div><div class="line">        this.prop = prop;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void serialize(Enum value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123;</div><div class="line">        if (value == null) &#123;</div><div class="line">            gen.writeNull();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            PropertyDescriptor pd = getPropertyDescriptor(value, prop);</div><div class="line">            if (pd == null || pd.getReadMethod() == null) &#123;</div><div class="line">                gen.writeString(value.name());</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            Method m = pd.getReadMethod();</div><div class="line">            m.setAccessible(true);</div><div class="line">            gen.writeObject(m.invoke(value));</div><div class="line">        &#125; catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</div><div class="line">            throw new CommonException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-2-自定义Enum-Deserializer"><a href="#3-3-2-自定义Enum-Deserializer" class="headerlink" title="3.3.2 自定义Enum Deserializer"></a>3.3.2 自定义Enum Deserializer</h4><blockquote>
<p>自定义枚举反序列化器，根据特定属性进行反序列化，如果无法找到，再尝试用枚举名进行反序列化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class CustomEnumDeserializer extends JsonDeserializer&lt;Enum&gt; implements ContextualDeserializer &#123;</div><div class="line"></div><div class="line">    @Setter</div><div class="line">    private Class&lt;Enum&gt; enumCls;</div><div class="line"></div><div class="line">    private String prop;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param prop 属性名</div><div class="line">     */</div><div class="line">    public CustomEnumDeserializer(@NotNull String prop) &#123;</div><div class="line">        Asserts.notBlank(prop);</div><div class="line"></div><div class="line">        this.prop = prop;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Enum deserialize(JsonParser parser, DeserializationContext ctx) throws IOException &#123;</div><div class="line">        String text = parser.getText();</div><div class="line">        return Enums.getEnum(enumCls, prop, text).orElseGet(() -&gt;</div><div class="line">                Stream.of(enumCls.getEnumConstants())</div><div class="line">                        .filter(e -&gt; e.name().equals(text))</div><div class="line">                        .findFirst().orElse(null)</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public JsonDeserializer createContextual(DeserializationContext ctx, BeanProperty property) throws JsonMappingException &#123;</div><div class="line">        Class rawCls = ctx.getContextualType().getRawClass();</div><div class="line">        Asserts.isTrue(rawCls.isEnum());</div><div class="line"></div><div class="line">        Class&lt;Enum&gt; enumCls = (Class&lt;Enum&gt;) rawCls;</div><div class="line">        CustomEnumDeserializer clone = new CustomEnumDeserializer(prop);</div><div class="line">        clone.setEnumCls(enumCls);</div><div class="line">        return clone;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整代码可以参见我在GitHub上的<a href="https://github.com/emac/spring-boot-features-demo" target="_blank" rel="external">示例工程</a>。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><ul>
<li><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="external">四种常见的 POST 提交数据方式</a></li>
<li><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="external">Spring Boot Reference Guide</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/1723270" target="_blank" rel="external">SpringMVC数据类型转换</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JUnit 5的前世今生]]></title>
      <url>http://emacoo.cn/arch/junit5/</url>
      <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><blockquote>
<p>前事不忘，后事之师。–《战国策·赵策一》</p>
</blockquote>
<p>对Java程序员而言，JUnit无疑是使用最广泛的单元测试框架。自2006年初JUnit 4发布之后，11年间陆陆续续更新了13个小版本，最新的4.12版本是在2014年底发布的。在现今新技术、新框架层出不穷的IT圈，JUnit的版本更新速度不可谓不缓慢，这一点上，和去年同期发布的<a href="http://emacoo.cn/devops/jenkins-2-0-from-ci-to-cd/">Jenkins 2.0</a>如出一辙，后者也花了11年才升级了一个大版本。让我们回到2006年初，看看当时的Java程序员都玩些啥？</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Java_(programming_language" target="_blank" rel="external">Java 5</a>发布1年多，很多公司还在使用JDK 1.4，离Java 6正式发布还有大半年，更别提Java 8了。</li>
<li><a href="https://en.wikipedia.org/wiki/Spring_Framework" target="_blank" rel="external">Spring</a>初出茅庐，离第一桶金Jolt和JAX大奖还有几个月，离2.0发布还有大半年，更别提Spring Boot和Spring Cloud了。</li>
<li><a href="https://en.wikipedia.org/wiki/Apache_Maven" target="_blank" rel="external">Maven</a>比Spring老道一点，不过也只是2.0 Beta阶段，更别提Maven 3了。</li>
</ul>
<p>了解了JUnit 4的出生背景，就不难理解如今JUnit 4的问题所在了。</p>
<ul>
<li>Extension：相对于其应用的体量，JUnit的可扩展性不可谓不粗糙。Runner和Rules是扩展JUnit的主要手段，前者虽然强大，但是粒度太粗，扩展者需要从零实现全测试周期的支持，并且一个单元测试类只能绑定一个Runner，无法同时使用多个Runner。Rules虽然解决了粒度的问题，但扩展能力非常有限，只能作用于测试周期的特定阶段。</li>
<li>Modularity：在Maven之前，一个Java应用依赖的Jar包往往都是人工进行管理的，既繁琐又容易出错，因此，那个时候all-in-one风格的fat Jar更受程序员欢迎。但是当Maven，Ivy以及之后Gradle接管了应用的依赖管理之后，模块化成为了主流，以前的fat Jar由于包的大小、更容易导致依赖冲突等原因逐渐的不再受到青睐，甚至被打入冷宫。</li>
<li>Java 8：距离Java 8正式发布已经整整过去3年，Java程序员也渐渐习惯了使用Lambda表达式，对于一些新生代的Java程序员而言，没有Lambda表达式甚至都不会写Java代码了。</li>
</ul>
<p>以上这些局限就构成了JUnit 5的起源。除此之外，JUnit 5还有更大的野心，JUnit as a Platform。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><blockquote>
<p>你的是我的，我的还是我的。</p>
</blockquote>
<p>什么是JUnit as a Platform？既然敢叫Platform，那目光自然就不能局限于JUnit自己了。通过引入JUnit Platform，JUnit 5不但可以运行新老版本的JUnit测试，甚至还可以运行别人家的单元测试，比如TestNG。套用一个现在流行的词，就叫降维打击。</p>
<p><img src="junit-5-architecture.png" alt=""><br><em>图片出处：<a href="https://www.infoq.com/articles/JUnit-5-Early-Test-Drive" target="_blank" rel="external">JUnit 5 - An Early Test Drive - Part 1</a></em></p>
<p>从上图可以看到，完整的JUnit 5平台从上至下分为四层：</p>
<ol>
<li>面向developer的API，比如各种测试注解</li>
<li>特定于某一单元测试框架的测试引擎，比如JUnit 4，JUnit 5，TestNG</li>
<li>通用的测试引擎，是对第2层各种单元测试框架的抽象</li>
<li>面向IDE的启动器，用于调度和执行各个单元测试</li>
</ol>
<p>前两层体现的是JUnit as a Tool，还属于Junit原本的范畴，而后两层体现的就是JUnit as a Platform，JUnit 5也借此实现了十年磨一剑的凤凰涅槃。有了JUnit as a Platform这把屠龙刀，相比于其他单元测试框架，可以说JUnit 5占据了技术制高点，可以预期，未来JUnit的版图将进一步扩大，将触角延伸至更多的测试领域。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>分析完JUnit 5架构上的调整，接下来再看一下除了Java 8的支持，JUnit 5具体包含了哪些值得一提的新特性。</p>
<ul>
<li>兼容性：为了最大程度的保证对JUnit 4以及更早版本的兼容性，JUnit 5启用了新的命名空间org.junit.jupiter.api.*，通过引入junit-vintage-engine模块，支持老的命名空间org.junit.*，并且新老版本可以共存于同一项目，独立运行互不影响。</li>
<li>新的注解：<ul>
<li>@DisplayName, @Tag注解：引入更灵活的基于字符串的@Tag注解，取代老的基于类的@Category注解，配以@DisplayName注解，让管理大量单元测试变得更容易。</li>
<li>@Nested注解：支持BDT(Behavior Driven Testing)风格的单元测试。</li>
</ul>
</li>
<li><a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests" target="_blank" rel="external">Parameterized Tests</a>：批量生成参数化的单元测试，比如针对一个枚举类，为其每一个枚举值生成一个单元测试。</li>
<li><a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests" target="_blank" rel="external">Dynamic Tests</a>：程序化生成单元测试，比如动态从数据库中读取数据，生成单元测试。</li>
<li><a href="http://junit.org/junit5/docs/current/user-guide/#extensions" target="_blank" rel="external">Extention</a>：JUnit 5提供了多种扩展方式，涉及测试周期的各个阶段，比如激活条件，参数解析，回调函数，异常处理等。通过实现特定接口，配合@ExtendWith注解，你很容易就可以重新定义一个单元测试的执行流程。</li>
</ul>
<p>为了更好的理解这些特性，不妨去GitHub看一下JUnit官方的<a href="https://github.com/junit-team/junit5-samples" target="_blank" rel="external">示例工程</a>。</p>
<h2 id="Roadmap"><a href="#Roadmap" class="headerlink" title="Roadmap"></a>Roadmap</h2><p>根据最新的JUnit<a href="https://github.com/junit-team/junit5/wiki/Roadmap" target="_blank" rel="external">官方文档</a>，JUnit 5将于今年第三季度的某一时刻发布，在此之前，还将发布若干个RC版本。目前最新的稳定版本是5.0.0-M4。</p>
<p>你，准备好了吗？</p>
<h2 id="附录：JUnit-5和JUnit-4的快速对比"><a href="#附录：JUnit-5和JUnit-4的快速对比" class="headerlink" title="附录：JUnit 5和JUnit 4的快速对比"></a>附录：JUnit 5和JUnit 4的快速对比</h2><p><img src="junit-5-vs-junit-4-9-638.jpg" alt=""><br><img src="junit-5-vs-junit-4-10-638.jpg" alt=""><br><em>图片出处：<a href="https://www.slideshare.net/rkmael/junit-5-vs-junit-4" target="_blank" rel="external">JUnit 5 vs JUnit 4</a></em></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="external">JUnit 5 User Guide</a></li>
<li><a href="https://www.infoq.com/articles/JUnit-5-Early-Test-Drive" target="_blank" rel="external">JUnit 5 - An Early Test Drive - Part 1</a></li>
<li><a href="https://www.slideshare.net/SpringCentral/testing-with-spring-43-junit-5-and-beyond" target="_blank" rel="external">Testing with Spring 4.3, JUnit 5, and Beyond</a></li>
<li><a href="https://objectpartners.com/2016/07/26/junit-5-with-spring-boot-plus-kotlin/" target="_blank" rel="external">JUnit 5 with Spring Boot (plus Kotlin)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【书友会】重读经典：《整洁代码》]]></title>
      <url>http://emacoo.cn/notes/book-clean-code/</url>
      <content type="html"><![CDATA[<blockquote>
<p>继“<a href="http://emacoo.cn/coding/source-retrofit/">赏码会</a>”之后，最近和团队开始尝试一种新的技术活动形式——“书友会”。简单来说，就是一起选出一些经典的技术书籍，线下阅读，当面讨论，共同进步。文末有具体的活动形式，欢迎到我的<a href="https://github.com/emac/emac.github.io/issues/2" target="_blank" rel="external">留言板</a>交流。</p>
</blockquote>
<p>作为“书友会”的第一期书籍，我们选择的是<a href="http://product.dangdang.com/20750190.html" target="_blank" rel="external">《代码整洁之道》</a>（后面简称《整洁》）。在我看来，《整洁》和另外两本经典之作<a href="http://product.dangdang.com/22543344.html" target="_blank" rel="external">《代码大全》</a>，<a href="http://product.dangdang.com/23734636.html" target="_blank" rel="external">《重构：改善既有代码的设计》</a>，是每一个程序员入行必读的三本基础技术书籍。这三本书能够帮助你建立正确的编程理念，养成良好的编程习惯。我建议可以按照《代码》，《重构》，《整洁》的顺序进行阅读。相对另外两本书，《整洁》涉及的面更广一些，内容也更有深度，比较适合有1~2年实际编程经验的程序员。不过即便是更资深的程序员，相信也能从中有所收获。我第一次读这本书还是在2010年，时隔7年重读这本经典之作，仍然感觉历久弥新。在介绍这本书之前，我们先来了解一个跟简洁有关的普适性原则。</p>
<h2 id="奥卡姆剃刀原则"><a href="#奥卡姆剃刀原则" class="headerlink" title="奥卡姆剃刀原则"></a>奥卡姆剃刀原则</h2><p><img src="occam.jpeg" alt=""></p>
<blockquote>
<p>奥卡姆剃刀定律（Occam’s Razor）又称“奥康的剃刀”，它是由14世纪逻辑学家、圣方济各会修士奥卡姆的威廉（William of Occam，约1285年至1349年）提出。这个原理称为“如无必要，勿增实体”，即“简单有效原理”。正如他在《箴言书注》2卷15题说“切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。” – <a href="http://baike.baidu.com/item/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80%E5%8E%9F%E7%90%86" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p>对应到编程，奥卡姆剃刀原则至少对我们有两个启示：</p>
<ul>
<li>如无必要，勿增实体。一个常见的反例就是代码前大段的注释，《整洁》告诉我们，最好的注释是没有注释，在你写下大段注释之前，应该反思一下是不是有更简单的设计。</li>
<li>对于同一个需求，如果有两种实现方案，选择那个简单的。网上经常可以看到一些装逼的代码，比如<a href="http://coolshell.cn/articles/17524.html" target="_blank" rel="external">这篇</a>，复杂的方案不仅增加了理解成本，更要命的是让问题变得更隐蔽。</li>
</ul>
<h2 id="整洁之道"><a href="#整洁之道" class="headerlink" title="整洁之道"></a>整洁之道</h2><p><img src="wtfm.jpg" alt=""></p>
<p>《整洁》这本书虽然章节颇多（算上附录A有18章），但每章内容并不多，平均半小时左右就可以读完一章，并且章节之间相互独立，打乱顺序阅读也无妨。为了保证讨论质量，我们总共分了4次（每周1次）进行逐章讨论，每次3~6章，时间控制在2小时以内。总的来说，辅以配图和代码，整本书的阅读体验很流畅，处处闪耀着大师们的编程智慧，摘录一二如下：</p>
<blockquote>
<p>童子军军规：让营地比你来时更干净。</p>
<p>整洁的代码从不隐藏设计者的意图。</p>
<p>读和写花费时间的比例超过10:1。写新代码时，我们一直在读旧代码。</p>
<p>整洁的代码总是看起来像是某位特别在意它的人写的。</p>
<p>勒布朗法则：稍后等于永不。</p>
<p>如果代码不能保持整洁，你就会失去它们。</p>
</blockquote>
<p>最后一句是我加的，哈！想要了解更多整洁之道？快去阅读《代码整洁之道》吧。</p>
<h2 id="“书友会”活动形式参考"><a href="#“书友会”活动形式参考" class="headerlink" title="“书友会”活动形式参考"></a>“书友会”活动形式参考</h2><p>目的：</p>
<ul>
<li>阅读经典，精进实践能力，提升思考维度</li>
<li>在碎片化阅读的当下，培养静心读书的定力</li>
</ul>
<p>目标：</p>
<ul>
<li>写一篇读书笔记</li>
<li>结合书本动手做一些实验</li>
</ul>
<p>形式：</p>
<ul>
<li>每周一次，每次不少于2小时，全体参加</li>
<li>每期书友会开始之前，选择一人作为主席，每人（包括主席）作为讲师认领若干章节</li>
<li>主席负责确定讲师，制定当期读书计划（分多少次，每次涉及章节）</li>
<li>每次活动开始前，所有人按读书计划提前读完读完计划内的章节</li>
<li>每次活动开始后，按读书计划先后由各位讲师主持小组讨论，交流读书心得</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="http://design.jobbole.com/118190/" target="_blank" rel="external">设计法则： 奥卡姆的剃刀原理</a></li>
<li><a href="http://www.wtoutiao.com/p/37eLKm8.html" target="_blank" rel="external">吴伯凡：为什么我们今天还要读文学经典</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【赏码会】Redis的最佳拍档：Jedis]]></title>
      <url>http://emacoo.cn/coding/source-jedis/</url>
      <content type="html"><![CDATA[<blockquote>
<p>出门左拐：</p>
<ul>
<li><a href="http://emacoo.cn/coding/source-retrofit/">【赏码会】HTTP Client中的瑞士军刀：Retrofit</a></li>
</ul>
</blockquote>
<h2 id="Jedis简介"><a href="#Jedis简介" class="headerlink" title="Jedis简介"></a>Jedis简介</h2><p>作为Redis官方推荐的三个<a href="https://redis.io/clients#java" target="_blank" rel="external">Java Client</a>之一，Jedis推出时间最早，使用最为广泛（Spring默认使用的Redis Client就是Jedis），同时Star数也遥遥领先于另外两个。和其他Redis Client一样，Jedis通过<a href="https://redis.io/topics/protocol" target="_blank" rel="external">RESP协议</a>向Redis发送命令请求和解析响应数据。</p>
<h2 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h2><p><img src="jedis-class-diagram.png" alt=""></p>
<p>最新版本的Jedis代码行数超过18K，和Redis本身（20K）处于同一规模。面对如此庞大的项目，分模块阅读是必然之选。由于类的数量太多，本文只在类层面进行简单解读，不会涉及具体的源代码。值得一提的是，虽然Jedis的代码称不上规范，比如全局缺注释、某些类的长度过长，但由于绝大多数方法都很简短，加上清晰的命名和完善的单元测试，代码可读性并没有太大影响。</p>
<h3 id="Core-核心模块，实现RESP协议"><a href="#Core-核心模块，实现RESP协议" class="headerlink" title="Core: 核心模块，实现RESP协议"></a>Core: 核心模块，实现RESP协议</h3><ul>
<li>Jedis/BinaryJedis: 入口类，封装Redis的各种命令。</li>
<li>Client/BinaryClient/Connection: 与Redis进行具体的交互工作。</li>
<li>Protocol, RedisInputStream, RedisOutputStream: 实现RESP协议。</li>
</ul>
<h3 id="Sharding-提供Partitioning支持"><a href="#Sharding-提供Partitioning支持" class="headerlink" title="Sharding: 提供Partitioning支持"></a>Sharding: 提供<a href="https://redis.io/topics/partitioning" target="_blank" rel="external">Partitioning</a>支持</h3><ul>
<li>ShardedJedis/BinaryShardedJedis: 首先对传入的Key进行Hash计算（默认使用高性能、低碰撞率的<a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="external">MurmurHash</a>算法），然后根据计算结果找到相应的Jedis实例，最后执行命令。</li>
</ul>
<h3 id="Pool-提供连接池和Sentinel支持"><a href="#Pool-提供连接池和Sentinel支持" class="headerlink" title="Pool: 提供连接池和Sentinel支持"></a>Pool: 提供连接池和<a href="https://redis.io/topics/sentinel" target="_blank" rel="external">Sentinel</a>支持</h3><ul>
<li>JedisPool: 基于<a href="https://commons.apache.org/proper/commons-pool/" target="_blank" rel="external">Apache Commons Pool</a>实现的连接池，通过JedisFactory获取Jedis实例。</li>
<li>JedisSentinelPool: 通过侦听”switch-master”事件，每当master切换时，调用JedisFactory重新初始化master连接信息。</li>
<li>ShardedJedisPool: 与JedisPool类似，通过ShardedJedisFactory获取ShardedJedis实例。</li>
</ul>
<h3 id="Pipeline-提供Pipelining和事务支持"><a href="#Pipeline-提供Pipelining和事务支持" class="headerlink" title="Pipeline: 提供Pipelining和事务支持"></a>Pipeline: 提供<a href="https://redis.io/topics/pipelining" target="_blank" rel="external">Pipelining</a>和<a href="https://redis.io/topics/transactions" target="_blank" rel="external">事务</a>支持</h3><ul>
<li>Pipeline: 通过Jedis#pipelined()获取实例。以类型安全的方式获取执行结果，通过BuilderFactory将Object类型的Response转化为期望的结果类型。<ul>
<li>非事务模式：构建Response Queue，然后通过Client#getMany()批量获取结果。</li>
<li>事务模式：通过MultiResponseBuilder缓存Response，然后批量获取结果。</li>
</ul>
</li>
<li>Transaction: 通过Jedis#multi()获取实例。天然的事务属性，通过Client#getMany()批量获取结果，但无法获取单条命令的结果，且类型非安全。</li>
<li>ShardedJedisPipeline: ShardedJedis#pipelined()获取实例。不同于Pipeline和Transaction，由于请求可能落到多个Client上，只能通过Client#getOne()挨个获取结果，类型非安全。</li>
</ul>
<h3 id="Cluster-提供Cluster支持"><a href="#Cluster-提供Cluster支持" class="headerlink" title="Cluster: 提供Cluster支持"></a>Cluster: 提供<a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="external">Cluster</a>支持</h3><ul>
<li>JedisCluster/BinaryJedisCluster: 通过JedisClusterConnectionHandler获取Jedis实例，然后执行命令。</li>
<li>JedisClusterConnectionHandler &amp; JedisClusterInfoCache: 通过Collections#shuffle()随机返回一个Jedis实例。使用ReentrantReadWriteLock保证更新Cluster的Jedis实例列表时的线程安全性。</li>
<li>JedisClusterCommand: 通过retry机制获取有效的Jedis实例，然后再执行命令。</li>
</ul>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><h3 id="Q1：为什么有那么多的Binary-类（BinaryJedis-BinaryClient-BinaryShardedJedis-BinaryJedisCluster），它们看上去跟非Binary的子类差不多啊？"><a href="#Q1：为什么有那么多的Binary-类（BinaryJedis-BinaryClient-BinaryShardedJedis-BinaryJedisCluster），它们看上去跟非Binary的子类差不多啊？" class="headerlink" title="Q1：为什么有那么多的Binary*类（BinaryJedis, BinaryClient, BinaryShardedJedis, BinaryJedisCluster），它们看上去跟非Binary的子类差不多啊？"></a>Q1：为什么有那么多的Binary*类（BinaryJedis, BinaryClient, BinaryShardedJedis, BinaryJedisCluster），它们看上去跟非Binary的子类差不多啊？</h3><p>A: Binary的父类与非Binary的子类表面的区别是不管是key，还是value，只要涉及字符串语义的参数，前者都用byte[]类型传参，而后者使用String类型。而深层次的原因，我认为跟RESP协议有关，RESP协议是面向字节的协议，对于性能要求极高的场景，使用Binary类有助于提高性能（因为减少了一次String到byte[]的转换）。</p>
<h3 id="Q2：Pipeline-Transaction以及普通的Jedis有何关联？"><a href="#Q2：Pipeline-Transaction以及普通的Jedis有何关联？" class="headerlink" title="Q2：Pipeline, Transaction以及普通的Jedis有何关联？"></a>Q2：Pipeline, Transaction以及普通的Jedis有何关联？</h3><p>A: 简单来说，Pipeline和Transaction是批处理运行模式，一次获取多条命令的执行结果，而Jedis只能一条一条获取。而Pipeline和Transaction的区别主要有两点：1）Pipeline同时支持事务模式和非事务模式，而Transaction支持事务模式。2）Pipeline类型安全，Transaction类型非安全。</p>
<h2 id="漫谈"><a href="#漫谈" class="headerlink" title="漫谈"></a>漫谈</h2><p>上面提到Jedis的代码规模很大，进一步分析排名靠前的几个大类，可以发现两个明显的特点：</p>
<p><img src="jedis-loc.png" alt=""></p>
<ol>
<li>方法很多，最多的一个类有250+方法，直接结果就是导致类的长度也很长（3000+）</li>
<li>大多数方法实现不超过5行，并且遵从同一结构</li>
</ol>
<p>单从缩减代码行数的角度来看，至少可以考虑两种方式：</p>
<ol>
<li>使用代码生成工具自动生成享有同一结构的方法</li>
<li>使用Java 8引入的Functional Interface简化代码</li>
</ol>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis GitHub</a></li>
<li><a href="https://redis.io/commands" target="_blank" rel="external">Redis Commands</a></li>
<li><a href="https://redis.io/documentation" target="_blank" rel="external">Redis Documentation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的写作工具箱]]></title>
      <url>http://emacoo.cn/notes/writing-toolbox/</url>
      <content type="html"><![CDATA[<p><img src="mac-coffee.jpg" alt=""></p>
<blockquote>
<p>出门左拐：</p>
<ul>
<li><a href="http://emacoo.cn/notes/why-i-write/">我们为什么要写作？</a></li>
<li><a href="http://emacoo.cn/notes/how-i-write/">我是如何写作的？</a></li>
</ul>
</blockquote>
<p>作为写作三部曲的最后一篇，展示一下我的日常写作工具箱。</p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>不夸张的说，没有Markdown，就没有现在这一波以掘金，简书，SegmentFault为代表的写作热。在Markdown之前，摆在程序员面前的写作格式主要有Word和Wiki。先说Word。对于文科生思维的办公人群，Word是不二之选，但对于理科生思维的程序员而言，Word里面的各种模板、段落格式、页眉页脚，就像孙悟空头上的紧箍咒，一想就头疼，尤其是像我这样有代码洁癖的程序员，字没码几个，排版排了一遍又一遍。Word的第二个问题在于可传播性，由于Word是一种二进制格式，需要用特定的软件才能打开，而在移动互联网时代，很少有人有耐心在阅读之前先下载一个文档，更别说很多人手机上可能都没有能够打开Word的App。</p>
<p>再看Wiki。Wiki虽然没有可传播性的问题，但极度依赖于网络，在离线环境下，你是没法编辑一个Wiki的。Wiki的另一个问题在于缺少统一的规范，我用过很多Wiki网站，虽然大体上支持的格式相同，但在纯文本编辑模式下，很多格式（比如加粗，链接）的表示方式不尽相同，这就让文章的可迁移性大打折扣。</p>
<p>Markdown可以说解决了上述所有的问题，通过统一的规范，纯文本排版，让写作的人能够专注于内容本身，而不用操心格式，最大化写作效率。Markdown另一个对程序员友好的特性是纯文本格式，既方便离线编辑，也容易对文章进行版本化管理。</p>
<p>我本地用的Markdown编辑软件是<a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime</a>, 配合<a href="https://github.com/jonschlinkert/sublime-markdown-extended" target="_blank" rel="external">Markdown Extended</a>和<a href="https://github.com/adampresley/sublime-view-in-browser" target="_blank" rel="external">View In Browser</a>插件。</p>
<h2 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h2><p>为了帮助读者更好的理解文章内容，一般每篇文章我都会配一些图片。配图目的不同，来源也会不同。对于技术类文章，如果是介绍第三方框架，我会优先引用官方网站的图片，然后是一些我读到的比较好的文章。如果是介绍自己开发的系统或者方案，我会自己画图，之前用<a href="https://www.yworks.com/products/yed" target="_blank" rel="external">yEd</a>或者<a href="https://www.processon.com/" target="_blank" rel="external">processon</a>比较多，最近发现<a href="https://chrome.google.com/webstore/detail/gliffy-diagrams/bhmicilclplefnflapjmnngmkkkkpfad?hl=zh-CN" target="_blank" rel="external">Gliffy Diagrams For Chrome</a>这个神器后基本上就用这个了，有时也会用一下Keynote或者Powerpoint。对于非技术类文章，Google是最好的搜图利器。</p>
<h2 id="建站工具"><a href="#建站工具" class="headerlink" title="建站工具"></a>建站工具</h2><p>有了文章和配图，接下来就要为它们找一个容身之处。我的这个个人站点最早是搭建在Amazon的AWS上面，用的CMS系统是<a href="https://getgrav.org/" target="_blank" rel="external">Grav</a>，后来服务器到期，就切换到GitHub上面了，用的是目前最流行的<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>，具体搭建步骤可以参考<a href="http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">这篇文章</a>。相对于Grav，Hexo更轻量，所有操作都可以在命令行下完成，支持一键发布到GitHub，非常方便。另一个我比较喜欢的Hexo的特性是草稿功能，对于一些你感兴趣但准备的还不够的主题，可以边做准备边写草稿，全部写完了再发布。</p>
<h2 id="写作环境"><a href="#写作环境" class="headerlink" title="写作环境"></a>写作环境</h2><p>对于程序员而言，写作是一种抽象程度更高的编程，需要放松的环境和专注的思考。对我而言，Mac，豆瓣FM，降噪耳机是不可或缺的陪伴。刻意的营造一些仪式感，可以帮助你更快的进入状态，比如一盏灯，一杯咖啡，一块超大鼠标垫。</p>
<p><img src="mi-mouse-pad.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我是如何写作的？]]></title>
      <url>http://emacoo.cn/notes/how-i-write/</url>
      <content type="html"><![CDATA[<blockquote>
<p>出门左拐：</p>
<ul>
<li><a href="http://emacoo.cn/notes/why-i-write/">我们为什么要写作？</a></li>
</ul>
</blockquote>
<h2 id="我的写作心得"><a href="#我的写作心得" class="headerlink" title="我的写作心得"></a>我的写作心得</h2><p><a href="http://emacoo.cn/notes/why-i-write/">上篇</a>文章谈了我对写作的一些认识，这篇文章继续聊一下我现阶段的一些写作心得。最近在《得到》上听到一篇吴军老师谈写作的<a href="http://www.jianshu.com/p/e3710e135208" target="_blank" rel="external">文章</a>，深以为然，对照这篇文章，同时结合我的一些经验，分4个步骤介绍一下我的写作流程。</p>
<h3 id="1-选题"><a href="#1-选题" class="headerlink" title="1 选题"></a>1 选题</h3><p>选题不分好坏，只看适不适合。那对于一个程序员，什么是适合的选题？在我看来，至少要满足两个条件：第一，感兴趣的，第二，有一些实践经验。兴趣是最好的老师，也会激发你最大的热情。有了兴趣的指引，你才能投入百分之百的热情，坚持不懈的探寻答案，并且做到精益求精。如果少了兴趣，写出来的文章往往平淡无味，并且更大的可能是半途而废。除了兴趣，有一些相关的实践经验也是不可或缺的。古人云，纸上得来终觉浅，绝知此事要躬行。王阳明也说，知行合一。读再多书，看再多文章，如果不动手实践一番，那还是别人的知识，写出来的文章也至多只能算是人云亦云。</p>
<h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h3><p>确定主题之后，下一步就是做一些准备工作，俗称做功课。就写博客而言，我一般至少提前一周开始准备。准备的内容包括：</p>
<ol>
<li><p>拟定文章标题和大纲。这是第一步也是最关键的一步。一个好的标题应该明确的告知读者文章的目的，这样既能够有效的吸引目标读者，也能够提前筛选掉不适合的读者。大纲划定了文章的广度，同时也描绘了文章的逻辑结构。比如那个著名的把大象放进冰箱的实验，大纲就是3句话，第一，打开冰箱门，第二，把大象放进冰箱，第三，关上冰箱门。<br><img src="elephant.png" alt=""></p>
</li>
<li><p>复读先前收藏的文章和记录的笔记，再加一些扩展阅读。还记得上篇文章我说的写作的第一个好处吗？复读也是一个温故知新的过程。同一篇文章，第一次读和第二次读往往会有不同的收获，也可能激发一些新的思考。除此之外，围绕上一步拟定的标题和大纲，针对一些不确定的点，再找一些相关材料进行学习和求证，需要的话，可以再补做一些实验。</p>
</li>
<li><p>总结现有的实践经验。从理解到实践是一次知行升级，从实践到写作又是一次知行升级。围绕写作这个目的，往往需要对先前的实践成果进行总结和加工，配以一些必要的图表，帮助读者更容易的理解你想表达的意思。</p>
</li>
</ol>
<h3 id="3-写作"><a href="#3-写作" class="headerlink" title="3 写作"></a>3 写作</h3><p>做了一定的准备之后，就可以开始写作了。但有一点切记，准备永远是不够的。新手写作，往往在准备的阶段停留太久，以至于准备到最后就不了了之。有了第一步的大纲和第二步的素材，真正的写作相对就会容易一些。写作的过程就是通过合理的组织文字和素材，达成你写当下这篇文章的目的。写作的技巧有很多，对我而言，最实用的两条是：第一，<a href="http://www.paulgraham.com/talk.html" target="_blank" rel="external">Write like you talk</a>，第二，写完一句再写下一句。这里就不展开解释了，留给你自己理解。</p>
<h3 id="4-传播"><a href="#4-传播" class="headerlink" title="4 传播"></a>4 传播</h3><p>如果你跟我一样，想通过写作提升自己的影响力，那么最后一步传播是必不可少的，毕竟在知识大爆炸的时代，酒香也怕巷子深。我目前用到的传播手段比较简单，除了个人站点之外，主要还是个人投稿（比如掘金，SegmentFault，CSDN等）和偶尔的第三方约稿。未来，等多一些积累，我可能会开设自己的公众号。如果你对我的文章感兴趣，也欢迎在我的<a href="https://github.com/emac/emac.github.io/issues/2" target="_blank" rel="external">留言板</a>留言约稿。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.paulgraham.com/writing44.html" target="_blank" rel="external">Writing, Briefly</a></li>
<li><a href="http://www.paulgraham.com/talk.html" target="_blank" rel="external">Write Like You Talk</a></li>
<li><a href="http://www.jianshu.com/p/e3710e135208" target="_blank" rel="external">成就只是你的副产品</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的2017书单]]></title>
      <url>http://emacoo.cn/notes/2017-booklist/</url>
      <content type="html"><![CDATA[<blockquote>
<p>2017，夕惕若厉，无咎</p>
</blockquote>
<h2 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h2><p><img src="23737589-1_w_2.jpg" alt=""><br><img src="23750530-1_w_2.jpg" alt=""></p>
<h2 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h2><p><img src="23750533-1_w_2.jpg" alt=""><br><img src="1900596121-1_w_2.jpg" alt=""><br><img src="23453503-1_w_2.jpg" alt=""><br><img src="23685951-1_w_2.jpg" alt=""><br><img src="23574522-1_w_7.jpg" alt=""><br><img src="23517521-1_w_1.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的2016书单]]></title>
      <url>http://emacoo.cn/notes/2016-booklist/</url>
      <content type="html"><![CDATA[<blockquote>
<p>2016，不虚度</p>
</blockquote>
<h2 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h2><p><img src="23754178-1_w_1.jpg" alt=""><br><img src="23363081-1_w_2.jpg" alt=""><br><img src="23855757-1_w_2.jpg" alt=""><br><img src="23678496-1_w_8.jpg" alt=""><br><img src="23232323-1_w_1.jpg" alt=""><br><img src="23634430-1_w_1.jpg" alt=""><br><img src="23595604-1_w_2.jpg" alt=""><br><img src="23347736-1_w_1.jpg" alt=""><br><img src="23654487-1_w_1.jpg" alt=""><br><img src="23795865-1_w_1.jpg" alt=""><br><img src="20629180-1_w_1.jpg" alt=""><br><img src="23539963-2_w_4.jpg" alt=""><br><img src="22937420-1_w_1.jpg" alt=""><br><img src="8851357-1_w_1.jpg" alt=""></p>
<h2 id="纸质"><a href="#纸质" class="headerlink" title="纸质"></a>纸质</h2><p><img src="9181074-1_w_1.jpg" alt=""><br><img src="23374205-1_w_2.jpg" alt=""><br><img src="23631999-1_w_2.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我们为什么要写作？]]></title>
      <url>http://emacoo.cn/notes/why-i-write/</url>
      <content type="html"><![CDATA[<h2 id="为什么要写作？"><a href="#为什么要写作？" class="headerlink" title="为什么要写作？"></a>为什么要写作？</h2><p>要回答这个问题，先来看看大咖们怎么说：</p>
<blockquote>
<p>Paul Graham (YC创始人): I think it’s far more important to write well than most people realize. Writing doesn’t just communicate ideas; it generates them.</p>
<p>Steve Yegge (Google): It’s become pretty clear to me that blogging is a source of both innovation and clarity. I have many of my best ideas and insights while blogging. Struggling to express things that you’re thinking or feeling helps you understand them better.</p>
<p>Shubhro Saha (Facebook): Software engineers should write because it promotes many of the same skills required in programming. A core skill in both disciplines is an ability to think clearly. The best software engineers are great writers because their prose is as logical and elegant as their code.</p>
<p>王建硕（百姓网创始人）：我把写东西完全当作自己的一个旅程，不是为了说服任何人，也不是为了传递什么信息。最主要是为了自己。我发现只有能优美、简洁、准确的把一个想法表达出来，我才敢说自己思考过了。否则落笔时，才发现有些概念依然模糊，或者答案还没有浮出水面。不写出来，自己就会浑然不知。</p>
<p>鬼脚七（前淘宝搜索负责人）：我知道一点，在我写文章的时候我很快乐，那是一种宁静的快乐。我每天睡觉经常只有6个来小时，白天我很忙碌，一直忙碌到晚上，但夜深人静时，就是我的欢乐时光。我每天很期待这一刻的到来，就像现在。</p>
<p>Fenny（前丁香园CTO）：在写公众号之前，我已经写过近十年的博客，六年的推特，三四年的微博，可以说几乎每天都在用键盘写东西，但无奈天分有限，也未受过严格训练，写的并不好。偶有寸进，心下会暗自窃喜。写作让我思想更为自由，感谢写作带给我的愉悦。</p>
<p>Roy Li（黑客，连续创业者）：就连我自己阅读的时候也像池院长所说的：自己看了都有收获。这便是写作的魅力，多尝试不同的角度思考和写作，对自身成长的帮助是不可估量的。</p>
</blockquote>
<p>就像一千个人眼里有一千个哈姆雷特，一千个人心中有一千个写作的理由。但有一点我相信是共通的，那就是有关自我成长。表面上看写作的对象是别人，但真实情况是，你是你自己最忠实的读者。你写的每一篇文章，第一个读者永远是你，阅读次数最多的也是你，最大的收益也归于你。在我看来，写作是完成自我迭代不可或缺的一环。身处移动互联网时代，我们的时间被极度的碎片化，大量的信息通过各种渠道涌入我们的大脑，感兴趣的、不感兴趣的，都在抢夺我们有限的注意力。写作的过程，就是将大脑中层出不穷、稍纵即逝的思维碎片整理成稳定、有序的文字的过程。这就好比Java里面的垃圾回收机制，一边将不再被引用的对象所占用的内存释放出来，一边将碎片化的内存重新整理成连续、有序的内存。</p>
<p><img src="gc.png" alt=""></p>
<h2 id="写作的益处"><a href="#写作的益处" class="headerlink" title="写作的益处"></a>写作的益处</h2><p>类似于<a href="http://emacoo.cn/coding/source-retrofit/">上篇</a>提到的阅读源代码，写作是更为典型的第二象限的事情（参见<a href="http://product.dangdang.com/23592549.html" target="_blank" rel="external">《高效能人士的七个习惯》</a>）。对我而言，写作至少意味着三个层面的益处。</p>
<p>第一，温故知新。写作是一个对已有知识重新思考的过程，在这个过程中很容易发现之前认知中的盲点，进而产生新的认知。并且在不断思考的过程中，有可能悟到一些宝贵的智慧。</p>
<p>第二，构建知识账本。知识账本是你所有可观测的知识的总和。每写出一篇文章，你的知识账本上就多了一条记录。并且只有写出来，你才有机会通过不断迭代来扩充你的认知。随着知识账本的不断累积，你的认知圈越来越大，相应的，接触到的未知领域也越来越多，你会变的越来越谦卑，离智慧也会越来越近。</p>
<p>第三，打造个人品牌，提升影响力。文章是最有效的传播手段，能够突破地理空间的限制，触达你原本难以企及的人群，并产生持续的影响力。一些好的文章或者著作，甚至可以跨越时间的长河，影响几十年后的读者。另一方面，写作是你和世界交流的窗口，你通过写作认识世界，世界也通过你写的文章认识你。</p>
<h2 id="为什么不写？"><a href="#为什么不写？" class="headerlink" title="为什么不写？"></a>为什么不写？</h2><p>既然写作有这么多好处，为什么还是有那么多人迟迟不愿动笔呢？没有时间或许是最常见的理由。Steve Yegge<a href="https://sites.google.com/site/steveyegge2/you-should-write-blogs" target="_blank" rel="external">一针见血</a>的指出了这个理由背后的根源：</p>
<blockquote>
<p>We’re all too busy to do things we don’t want to do.</p>
</blockquote>
<h2 id="我写作的经历"><a href="#我写作的经历" class="headerlink" title="我写作的经历"></a>我写作的经历</h2><p>有一点要强调一下，上文所说的写作是指主动写作，不包括那些应试的或者任务型的被动写作。在这个意义上，我写作的经历大致可以分为三个阶段：上大学之前的日记，大学阶段的博客以及现在的个人站点。虽然我工作近10年，真正意义上的写作却只能从去年年底建立这个个人站点为开始。相比现在很多毕业没几年就有了个人站点甚至还开设了公众号的90后，我算是起了个大早，赶了个晚集。好在写作这条路很长，如同瀚无边际的宇宙，什么时候开始并不重要，重要的是开始本身。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="http://www.paulgraham.com/writing44.html" target="_blank" rel="external">Writing,  Briefly</a></li>
<li><a href="http://www.shubhro.com/2014/12/27/software-engineers-should-write/" target="_blank" rel="external">Software engineers should write</a></li>
<li><a href="https://sites.google.com/site/steveyegge2/you-should-write-blogs" target="_blank" rel="external">You Should Write Blogs</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzI0Mjg0MA==&amp;mid=2652370987&amp;idx=1&amp;sn=c8083fd148a94fa2f4b74986b3045f03&amp;scene=0#wechat_redirect" target="_blank" rel="external">有人写文章就是为了促进思考</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM3NjIyMA==&amp;mid=10000469&amp;idx=1&amp;sn=958bb0eaecb241a2811f8e534172161c&amp;scene=0#wechat_redirect" target="_blank" rel="external">做自己·爱生活–写在微信订阅量超过十万</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968841&amp;idx=1&amp;sn=67895f27a4c65cb9c84ae48b27cbd5bc&amp;scene=0#wechat_redirect" target="_blank" rel="external">小道消息，开通四年了</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTc2MDEzMw==&amp;mid=200149125&amp;idx=1&amp;sn=b3b85ffe7f180ed635a6a4c7bb56f064&amp;scene=1#rd" target="_blank" rel="external">写作的角度</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【赏码会】HTTP Client中的瑞士军刀：Retrofit]]></title>
      <url>http://emacoo.cn/coding/source-retrofit/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近开始在GitHub上找一些优秀的开源项目，跟团队一起阅读源代码，每周一次，每次一个半小时左右，美其名曰“赏码会”（还记得《唐伯虎点秋香》那句“赏花赏月赏秋香”吗？）。为什么要阅读源代码？好处举不胜举，比如学习如何合理的命名，如何写出简洁、清晰的注释，如何编写有效的单元测试，知道良好的编码风格是什么样的。有一些积累之后，可以试试看找一找隐藏在代码里的设计模式，加一些新的单元测试，想一想如果自己实现会如何设计，亦或者尝试提交一个PR，修复一个Issue。阅读源代码可以说是有百利而无一害，属于典型的第二象限的事情（参见<a href="http://product.dangdang.com/23592549.html" target="_blank" rel="external">《高效能人士的七个习惯》</a>）。</p>
<h2 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h2><p>第一次“赏码会”我选的是<a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>项目，为什么选它呢？第一，小巧（核心代码不到5000行），第二，高Star（17+K），第三，平时一直在用。先简单介绍一下Retrofit这个框架。Retrofit是<a href="https://squareup.com/global/en/pos" target="_blank" rel="external">Square</a>公司开源的一个Java实现的轻量级HTTP Client框架，本质上是对Square公司另一个开源框架OkHTTP的一层type-safe的封装。所谓的type-safe，我的理解就是将OkHTTP原生的Request/Response对象通过类型安全的方式转化为其他任意类型的对象，比如String，用户自定义类型等。</p>
<p>面向接口的声明式API定义风格是Retrofit最受欢迎的特性，例如下面的GitHubService接口的listRepos方法定义了GitHub的<a href="https://developer.github.com/v3/repos/#list-user-repositories" target="_blank" rel="external">List user repositories</a> API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无需定义具体的实现类，就可以直接调用，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure>
<p>有经验的Java程序员立刻就能看出，相对于其他的HTTP Client框架，比如<a href="https://hc.apache.org/" target="_blank" rel="external">Apache HttpClient</a>或者<a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="external">Async Http Client</a>，使用Retrofit将使编程效率产生质的提升。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p>从GitHub拉取Retrofit的源代码，导入retrofit子工程，核心代码都在retrofit包下。</p>
<p><img src="retrofit-project.png" alt=""></p>
<p>核心类列举如下：</p>
<ul>
<li>Retrofit: Retrofit框架的门面类，大多数情况下，你的代码中只需要用到它。</li>
<li>ServiceMethod: 对应接口类中的一个方法（比如上文中的listRepos），负责解析方法签名中用到的各种注解，生成最终的Request对象。</li>
<li>Call: 类似于Java 8里面的CompletableFuture，提供异步支持。</li>
<li>CallAdapter: Retrofit默认只接受Call&lt;?&gt;作为方法返回类型，如果需要使用其他类型，就要添加额外的CallAdapter。</li>
<li>Converter: Retrofit默认只接受Response和Void作为Call&lt;?&gt;的类型参数，如果需要使用其他类型，就要添加额外的Converter。</li>
</ul>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>和任何形式的阅读（读书，读人，读心）一样，要读懂源代码，一定要带着问题去读。为了帮助理解上述几个核心类的关系，简单列举几个我阅读代码时思考的问题，</p>
<h3 id="Q1：为什么只有接口？实现类在哪？"><a href="#Q1：为什么只有接口？实现类在哪？" class="headerlink" title="Q1：为什么只有接口？实现类在哪？"></a>Q1：为什么只有接口？实现类在哪？</h3><p>A: 答案很简单，因为使用了JDK的动态代理，非常讨巧的设计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">  Utils.validateServiceInterface(service);</div><div class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">    eagerlyValidateMethods(service);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable &#123;</div><div class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">          &#125;</div><div class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Q2：我不想用Call，怎样才能使用其他返回类型？"><a href="#Q2：我不想用Call，怎样才能使用其他返回类型？" class="headerlink" title="Q2：我不想用Call，怎样才能使用其他返回类型？"></a>Q2：我不想用Call，怎样才能使用其他返回类型？</h3><p>A: 刚才已经提到了，通过Retrofit.Builder#addCallAdapterFactory()添加相应的CallAdapter，例如想返回CompleteableFuture，可以使用Retrofit提供的<a href="https://github.com/square/retrofit/blob/master/retrofit-adapters/java8/src/main/java/retrofit2/adapter/java8/Java8CallAdapterFactory.java" target="_blank" rel="external">Java8CallAdapterFactory</a>。</p>
<h3 id="Q3：如何打印请求和响应日志？"><a href="#Q3：如何打印请求和响应日志？" class="headerlink" title="Q3：如何打印请求和响应日志？"></a>Q3：如何打印请求和响应日志？</h3><p>A: 跟动态设置Headers类似，可以自定义用于打印日志的<a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">OkHttp interceptor</a>，然后添加到自己创建的OkHttpClient实例，再绑定Retrofit.Builder#client()。</p>
<h2 id="漫谈"><a href="#漫谈" class="headerlink" title="漫谈"></a>漫谈</h2><p>总的来说，Retrofit框架设计精巧，上手简单，开发效率高，但也存在一些不足。第一，跟OkHTTP框架绑定太死，不像<a href="https://github.com/OpenFeign/feign" target="_blank" rel="external">Feign</a>那么灵活，支持多种Client。第二，和JDK的动态代理强绑定，对其他AOP方式不友好，比如这个<a href="https://github.com/square/retrofit/issues/2113" target="_blank" rel="external">Issue</a>提到的Hystrix集成问题。</p>
<p>今天先写到这里，未来我会不定期放一些“赏码会”的心得，欢迎到GitHub<a href="https://github.com/emac/emac.github.io/issues/2" target="_blank" rel="external">留言</a>交流。</p>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit 官网</a></li>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit GitHub</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微服务化改造系列之四：授权中心]]></title>
      <url>http://emacoo.cn/arch/microservice-oauth2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前情概要：</p>
<ul>
<li><a href="http://emacoo.cn/arch/microservice-overview">微服务化改造系列之一：总览</a></li>
<li><a href="http://emacoo.cn/arch/microservice-registry-center/">微服务化改造系列之二：服务注册中心</a></li>
<li><a href="http://emacoo.cn/arch/microservice-config/">微服务化改造系列之三：配置中心</a></li>
</ul>
</blockquote>
<h2 id="授权中心概述"><a href="#授权中心概述" class="headerlink" title="授权中心概述"></a>授权中心概述</h2><p>这篇文章是微服务化改造系列的第四篇，主题是授权中心。有了服务注册中心和配置中心，下一步应该就可以发起服务调用了吧？Wait, 还有一个关键问题要解决。不同于单体应用内部的方法调用，服务调用存在一个服务授权的概念。打个比方，原本一家三兄弟住一屋，每次上山打猎喊一声就行，后来三兄弟分了家，再打猎就要挨家挨户敲门了。这一敲一应就是所谓的服务授权。</p>
<p>严格来说，服务授权包含鉴权（Authentication）和授权（Authorization）两部分。鉴权解决的是调用方身份识别的问题，即敲门的是谁。授权解决的是调用是否被允许的问题，即让不让进门。两者一先一后，缺一不可。为避免歧义，如不特殊指明，下文所述授权都是宽泛意义上的授权，即包含了鉴权。</p>
<p>常见的服务授权有三种，简单授权，协议授权和中央授权。</p>
<ul>
<li>简单授权：服务提供方并不进行真正的授权，而是依赖于外部环境进行自动授权，比如IP地址白名单，内网域名等。这就好比三兄弟互相留了一个后门。</li>
<li>协议授权：服务提供方和服务调用方事先约定一个密钥，服务调用方每次发起服务调用请求时，用约定的密钥对请求内容进行加密生成鉴权头（包含调用方唯一识别ID），服务提供方收到请求后，根据鉴权头找到相应的密钥对请求进行鉴权，鉴权通过后再决定是否授权此次调用。这就好比三兄弟之间约定敲一声是大哥，敲两声是二哥，敲三声是三弟。</li>
<li>中央授权：引入独立的授权中心，服务调用方每次发起服务调用请求时，先从授权中心获取一个授权码，然后附在原始请求上一起发给服务提供方，提供方收到请求后，先通过授权中心将授权码还原成调用方身份信息和相应的权限列表，然后决定是否授权此次调用。这就好比三兄弟每家家门口安装了一个110联网的指纹识别器，通过远程指纹识别敲门人的身份。</li>
</ul>
<p>一般来说，简单授权在业务规则简单、安全性要求不高的场景下用的比较多。而协议授权，比较适用于点对点或者C/S架构的服务调用场景，比如<a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html" target="_blank" rel="external">Amazon S3 API</a>。对于网状结构的微服务而言，中央授权是三种方式中最适合也是最灵活的选择：</p>
<ol>
<li>简化了服务提供方的实现，让提供方专注于权限设计而非实现。</li>
<li>更重要的是提供了一套独立于服务提供方和服务调用方的授权机制，无需重新发布服务，只要在授权中心修改服务授权规则，就可以影响后续的服务调用。</li>
</ol>
<h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p>说起具体的授权协议，很多人第一反应就是OAuth。事实上也的确如此，很多互联网公司的开放平台都是基于OAuth协议实现的，比如<a href="https://developers.google.com/identity/protocols/OAuth2" target="_blank" rel="external">Google APIs</a>, <a href="http://mp.weixin.qq.com/wiki/4/9ac2e7b1f1d22e9e57260f6553822520.html" target="_blank" rel="external">微信网页授权接口</a>。一次标准的OAuth授权过程如下：</p>
<p><img src="oauth2.png" alt=""></p>
<p>对应到微服务场景，服务提供方相当于上图中的Resource Server，服务调用方相当于Client，而授权中心相当于Authorization Server和Resource Owner的合体。</p>
<p>想了解更多关于OAuth的信息，可移步<a href="http://oauthlib.readthedocs.io/en/latest/oauth2/oauth2.html" target="_blank" rel="external">OAuth2</a>或者<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">OAuth2中文版</a>。</p>
<h3 id="Beared-Token"><a href="#Beared-Token" class="headerlink" title="Beared Token"></a>Beared Token</h3><p>在标准的OAuth授权过程中，Resource Server收到Client发来的请求后，需要到Authorization Server验证Access Token，并获取Client的进一步信息。通过OAuth 2.0版本引入中的Beared Token，我们可以省去这一次调用，将Client信息存入Access Token，并在Resource Server端完成Access Token的鉴权。主流的Beared Token有<a href="http://samltool.io/" target="_blank" rel="external">SAML</a>和<a href="https://jwt.io/introduction/" target="_blank" rel="external">JWT</a>两种格式，SAML基于XML，而JWT基于JSON。由于大多数微服务都使用JSON作为序列化格式，JWT使用的更为广泛。</p>
<h2 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h2><p>在选型OAuth框架时，我主要调研了<a href="https://github.com/apereo/cas" target="_blank" rel="external">CAS</a>,<a href="http://oltu.apache.org/" target="_blank" rel="external">Apache Oltu</a>,<a href="http://projects.spring.io/spring-security-oauth/" target="_blank" rel="external">Spring Security OAuth</a>和<a href="https://github.com/OAuth-Apis/apis" target="_blank" rel="external">OAuth-Apis</a>，对比如下：</p>
<p><img src="oauth2-frameworks.png" alt=""></p>
<p>不考虑实际业务场景，CAS和Spring Security OAuth相对另外两种框架，无论是集成成本还是可扩展性，都有明显优势。前文提到，由于我们选用了Spring Boot作为统一的微服务实现框架，Spring Security OAuth是更自然的选择，并且维护成本相对低一些（服务端）。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>最后我们基于Spring Security OAuth框架实现了自己的服务授权中心，鉴权部分做的比较简单，目前只支持私网认证。大致的服务授权流程如下：</p>
<p><img src="oauth2-interaction.png" alt=""></p>
<p><img src="oauth2-sequence.png" alt=""></p>
<p>值得一提的是，除了服务调用，我们的服务授权中心还增加了SSO的支持，通过微信企业号实现各个服务后台的单点登录/登出，以后有机会再详细介绍。</p>
<h2 id="冰山一角"><a href="#冰山一角" class="headerlink" title="冰山一角"></a>冰山一角</h2><p>至此，这个微服务化改造系列就算告一段落，等以后有了更多的积累，我会继续写下去。微服务是一个很大的话题，自Martin Fowler于<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">2014年3月</a>提出以来，愈演愈热，并跟另一个话题容器化一起开创了一个全新的DevOps时代，引领了国内外大大小小各个互联网公司的技术走向，也影响了我们这一代程序员尤其是后端和运维的思维方式。从这个角度说，我写这个微服务化改造系列文章也是偶然中的必然，希望能给读过这些文章的你带来一些新的启发和思考。如果你对微服务也感兴趣或者有一些心得想跟我交流，欢迎在<a href="https://github.com/emac/emac.github.io/issues/1" target="_blank" rel="external">赞赏榜</a>上留下你的微信号。</p>
<blockquote>
<p>少年读书如隙中窥月，中年读书如庭中望月，老年读书如台上玩月，皆以阅历之浅深为所得之浅深耳。– 张潮 《幽梦影》</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://oauthlib.readthedocs.io/en/latest/oauth2/oauth2.html" target="_blank" rel="external">OAuth2</a> - <a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">中文版</a></li>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="external">JWT</a></li>
<li><a href="https://github.com/apereo/cas" target="_blank" rel="external">CAS</a></li>
<li><a href="http://oltu.apache.org/" target="_blank" rel="external">Apache Oltu</a></li>
<li><a href="https://github.com/OAuth-Apis/apis" target="_blank" rel="external">OAuth-Apis</a></li>
<li><a href="http://projects.spring.io/spring-security-oauth/" target="_blank" rel="external">Spring Security OAuth</a></li>
<li><a href="http://projects.spring.io/spring-security-oauth/docs/oauth2.html" target="_blank" rel="external">OAuth 2 Developers Guide</a> </li>
<li><a href="https://blog.yorkxin.org/2013/09/30/oauth2-implementation-differences-among-famous-sites" target="_blank" rel="external">各大網站 OAuth 2.0 實作差異</a></li>
<li>参考示例：<a href="https://github.com/spring-projects/spring-security-oauth/tree/master/samples" target="_blank" rel="external">spring-security-oauth</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微服务化改造系列之三：配置中心]]></title>
      <url>http://emacoo.cn/arch/microservice-config/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前情概要：</p>
<ul>
<li><a href="http://emacoo.cn/arch/microservice-overview">微服务化改造系列之一：总览</a></li>
<li><a href="http://emacoo.cn/arch/microservice-registry-center/">微服务化改造系列之二：服务注册中心</a></li>
</ul>
</blockquote>
<h2 id="配置中心概述"><a href="#配置中心概述" class="headerlink" title="配置中心概述"></a>配置中心概述</h2><p>这篇文章是微服务化改造系列的第三篇，主题是配置中心。上一篇我们谈到服务注册中心，即通过提供某种注册和发现的机制，解决服务互通的问题。那么问题来了，一个服务如何知道服务注册中心的地址呢？这就涉及到服务配置了。我们知道，大至一个PaaS平台，小至一个缓存框架，一般都依赖于特定的配置以正常提供服务，微服务也不例外。</p>
<h3 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h3><ul>
<li>按配置的来源划分，主要有源代码（俗称hard-code），文件，数据库和远程调用。</li>
<li>按配置的适用环境划分，可分为开发环境，测试环境，预发布环境，生产环境等。</li>
<li>按配置的集成阶段划分，可分为编译时，打包时和运行时。编译时，最常见的有两种，一是源代码级的配置，二是把配置文件和源代码一起提交到代码仓库中。打包时，即在应用打包阶段通过某种方式将配置（一般是文件形式）打入最终的应用包中。运行时，是指应用启动前并不知道具体的配置，而是在启动时，先从本地或者远程获取配置，然后再正常启动。</li>
<li>按配置的加载方式划分，可分为单次加载型配置和动态加载型配置。</li>
</ul>
<h3 id="演变"><a href="#演变" class="headerlink" title="演变"></a>演变</h3><p>随着业务复杂度的上升和技术架构的演变，对应用的配置方式也提出了越来越高的要求。一个典型的演变过程往往是这样的，起初所有配置跟源代码一起放在代码仓库中；之后出于安全性的考虑，将配置文件从代码仓库中分离出来，或者放在CI服务器上通过打包脚本打入应用包中，或者直接放到运行应用的服务器的特定目录下，剩下的非文件形式的关键配置则存入数据库中。上述这种方式，在单体应用阶段非常常见，也往往可以运行的很好，但到了微服务阶段，面对爆发式增长的应用数量和服务器数量，就显得无能为力了。这时，就轮到配置中心大显身手了。那什么是配置中心？简单来说，就是一种统一管理各种应用配置的基础服务组件。</p>
<h2 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h2><p>选型一个合格的配置中心，至少需要满足如下4个核心需求：</p>
<ul>
<li>非开发环境下应用配置的保密性，避免将关键配置写入源代码</li>
<li>不同部署环境下应用配置的隔离性，比如非生产环境的配置不能用于生产环境</li>
<li>同一部署环境下的服务器应用配置的一致性，即所有服务器使用同一份配置</li>
<li>分布式环境下应用配置的可管理性，即提供远程管理配置的能力</li>
</ul>
<p>现在开源社区主流的配置中心框架有Spring Cloud Config和disconf，两者都满足了上述4个核心需求，但又有所区别。</p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p><img src="spring-cloud-config.png" alt=""></p>
<p><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_config" target="_blank" rel="external">Spring Cloud Config</a>可以说是一个为Spring量身定做的轻量级配置中心，巧妙的将应用运行环境映射为profile，应用版本映射为label。在服务端，基于特定的外部系统（Git、文件系统或者Vault）存储和管理应用配置；在客户端，利用强大的Spring配置系统，在运行时加载应用配置。</p>
<h3 id="disconf"><a href="#disconf" class="headerlink" title="disconf"></a>disconf</h3><p><img src="disconf.jpg" alt=""></p>
<p><a href="http://disconf.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="external">disconf</a>是前百度资深研发工程师廖绮绮的开源作品。在服务端，提供了完善的操作界面管理各种运行环境，应用和配置文件；在客户端，深度集成Spring，通过Spring AOP实现应用配置的自动加载和刷新。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>不管是Spring Cloud Config还是disconf，默认提供的客户端都深度绑定了Spring框架，这对非Spring应用而言无疑增加了集成成本，即便它们都提供了获取应用配置的API。最终我们还是选用了微服务化改造之前自研的Matrix作为配置中心，一方面，可以保持新老系统使用同一套配置服务，降低维护成本，另一方面，在满足4个核心需求的前提下，Matrix还提供了一些独有的能力。</p>
<ul>
<li>分离配置文件和配置项。对于配置文件，通过各类配套打包插件（sbt, maven, gradle），在打包时将配置文件打入应用包中，同时最小化对CI的侵入性；对于配置项，提供SDK，帮助应用从服务端获取配置项，同时支持简单的缓存机制。</li>
<li>增加应用版本维度，即对于同一应用，可以在服务端针对不同版本或版本区间维护不同的应用配置。</li>
<li>应用配置的版本化支持，类似于Git，可以将任一应用配置回退到任一历史版本。</li>
</ul>
<p>进一步信息可参考我之前写的Matrix<a href="https://www.zybuluo.com/emac/note/241756" target="_blank" rel="external">设计文档</a>。</p>
<p><img src="matrix.png" alt=""></p>
<p><em>Matrix架构图</em></p>
<p>下一篇我将给大家介绍微服务架构的另一个基础组件——授权中心，敬请期待！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_config" target="_blank" rel="external">Spring Cloud Config</a></li>
<li><a href="http://disconf.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="external">disconf</a></li>
<li><a href="https://www.zybuluo.com/emac/note/241756" target="_blank" rel="external">Matrix</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微服务化改造系列之二：服务注册中心]]></title>
      <url>http://emacoo.cn/arch/microservice-registry-center/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前情概要：<a href="http://emacoo.cn/arch/microservice-overview">微服务化改造系列之一：总览</a></p>
</blockquote>
<h2 id="服务注册中心概述"><a href="#服务注册中心概述" class="headerlink" title="服务注册中心概述"></a>服务注册中心概述</h2><p>这篇文章是微服务化改造系列的第二篇，主题是服务注册中心。作为微服务架构最基础也是最重要的组件之一，服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。</p>
<p>设计或者选型一个服务注册中心，首先要考虑的就是服务注册与发现机制。纵观当下各种主流的服务注册中心解决方案，大致可归为三类：</p>
<ul>
<li>应用内：直接集成到应用中，依赖于应用自身完成服务的注册与发现，最典型的是Netflix提供的<a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Eureka</a></li>
<li>应用外：把应用当成黑盒，通过应用外的某种机制将服务注册到注册中心，最小化对应用的侵入性，比如Airbnb的<a href="http://nerds.airbnb.com/smartstack-service-discovery-cloud/" target="_blank" rel="external">SmartStack</a>，HashiCorp的<a href="https://www.consul.io/" target="_blank" rel="external">Consul</a></li>
<li>DNS：将服务注册为DNS的SRV记录，严格来说，是一种特殊的应用外注册方式，<a href="https://github.com/skynetservices/skydns" target="_blank" rel="external">SkyDNS</a>是其中的代表</li>
</ul>
<p><em>注1：对于第一类注册方式，除了Eureka这种一站式解决方案，还可以基于ZooKeeper或者Etcd自行实现一套服务注册机制，这在大公司比较常见，但对于小公司而言显然性价比太低。</em></p>
<p><em>注2：由于DNS固有的缓存缺陷，本文不对第三类注册方式作深入探讨。</em></p>
<p>除了基本的服务注册与发现机制，从开发和运维角度，至少还要考虑如下五个方面：</p>
<ul>
<li>测活：服务注册之后，如何对服务进行测活以保证服务的可用性？</li>
<li>负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？</li>
<li>集成：在服务提供端或者调用端，如何集成注册中心？</li>
<li>运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？</li>
<li>可用性：如何保证注册中心本身的可用性，特别是消除单点故障？</li>
</ul>
<p>以下就围绕上述几个方面，简单分析一下Eureka，SmartStack，Consul的利弊。</p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p><img src="eureka.png" alt=""></p>
<p>从设计角度来看，Eureka可以说是无懈可击，注册中心、提供者、调用者边界清晰，通过去中心化的集群支持保证了注册中心的整体可用性，但缺点是Eureka属于应用内的注册方式，对应用的侵入性太强，且只支持Java应用。</p>
<h3 id="SmartStack"><a href="#SmartStack" class="headerlink" title="SmartStack"></a>SmartStack</h3><p><img src="smartstack.png" alt=""></p>
<p>SmartStack可以说是三种方案中最复杂的，涉及了ZooKeeper、HAProxy、Nerve和Synapse四种异构组件，对运维提出了很高的要求。它最大的好处是对应用零侵入，且适用于任意类型的应用。</p>
<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p><img src="consul-standard.png" alt=""></p>
<p>Consul本质上属于应用外的注册方式，但可以通过SDK简化注册流程。而服务发现恰好相反，默认依赖于SDK，但可以通过Consul Template（下文会提到）去除SDK依赖。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>最终我们选择了Consul作为服务注册中心的实现方案，主要原因有两点：</p>
<ol>
<li>最小化对已有应用的侵入性，这也是贯穿我们整个微服务化改造的原则之一</li>
<li>降低运维的复杂度，Consul Agent既可以运行在服务器模式，又可以运行在客户端模式</li>
</ol>
<h3 id="Consul-Template"><a href="#Consul-Template" class="headerlink" title="Consul Template"></a>Consul Template</h3><p>上文提到使用Consul，默认服务调用者需要依赖Consul SDK来发现服务，这就无法保证对应用的零侵入性。所幸通过<a href="https://github.com/hashicorp/consul-template" target="_blank" rel="external">Consul Template</a>，可以定时从Consul集群获取最新的服务提供者列表并刷新LB配置（比如nginx的upstream），这样对于服务调用者而言，只需要配置一个统一的服务调用地址即可。改造后的调用关系如下：</p>
<p><img src="consul-template.png" alt=""></p>
<h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><p>由于我们选用了Spring Boot作为统一的微服务实现框架，很自然的，可以利用Spring Cloud提供的Consul组件进一步简化服务注册流程，省去额外的服务提供端的Consul配置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.consul.io/docs/index.html" target="_blank" rel="external">CONSUL DOCUMENTATION</a></li>
<li><a href="https://github.com/hashicorp/consul-template" target="_blank" rel="external">consul-template</a></li>
<li><a href="http://cloud.spring.io/spring-cloud-consul/" target="_blank" rel="external">Spring Cloud Consul</a></li>
<li><a href="http://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html" target="_blank" rel="external">Spring Cloud Netflix</a></li>
<li><a href="http://nobodyiam.com/2016/06/25/dive-into-eureka/" target="_blank" rel="external">Dive into Eureka</a></li>
<li><a href="http://nerds.airbnb.com/smartstack-service-discovery-cloud/" target="_blank" rel="external">SmartStack: Service Discovery in the Cloud</a></li>
<li><a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="external">Open-Source Service Discovery</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微服务化改造系列之一：总览]]></title>
      <url>http://emacoo.cn/arch/microservice-overview/</url>
      <content type="html"><![CDATA[<h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1 写在前面"></a>1 写在前面</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>技术圈流行一句话，凡脱离业务谈架构的，都是耍流氓。作为微服务改造系列的第一篇博客，首先介绍一下实施这次技术改造的背景。</p>
<p>第一，我所在公司（简称XR）的后台服务采用的主技术栈是Scala，虽然开发效率很高，但也带来一系列的副作用。1.由于Scala语言强大的表达能力和丰富的函数式特性，很容易写出俗称“意大利面条”式的代码，一个类文件动辄上千行，代码的可读性非常差，导致可维护性也很差。2.编译Scala源码时首先需要将Scala源码转换成Java源码然后再通过JVM进行编译，加上隐式类型的存在进一步拖慢了编译期间的类型推导，Scala的编译速度比Java足足慢了一个数量级，这个差异在代码量少的时候还不明显，但随着代码量的上升，就成了团队的一个nightmare，试想本地全量编译一次需要10+分钟。3.Scala小众语言的标签决定了Scala程序员的稀缺性，晦涩难懂的官方文档拔高了学习曲线，后果就是高昂的招聘成本和漫长的培养时间。以上这些副作用不但抵消了先期开发效率上的优势，而且使得对新需求的响应能力越来越慢，技术负债也越垒越高。</p>
<p>第二，历经2年多的产品迭代，整个后台服务项目越来越庞大，已经成为一个典型意义上的单体应用（也就是Martin Fowler常说的monolithic application）：1.各个业务模块犬牙交错，重复代码随处可见，补丁代码越打越多。2.任何一个改动都需要一次全量发布，哪怕是修改一句文案。</p>
<p>第三，与微服务化改造同时进行的是容器化改造，如果不对上述单体应用进行拆分，很多容器化带来的好处就会被削弱，甚至毫无意义，比如提高资源利用率（CPU型应用和内存型应用搭配部署），异构应用的环境隔离能力等。</p>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>谷歌前研发总监Tiger曾经说过，一个系统的演化一般会经历三个阶段，首先是under-engineer，然后是over-engineer，最后才是right-engineer。考虑到参与此次微服务改造的人员有限（一人主导，多人配合），同时也是团队第一次尝试做这类系统性的改造，最后我们决定采取一条比较实用的改良式路线：</p>
<ol>
<li>最小化对已有应用的侵入性</li>
<li>偏好主流的微服务框架</li>
<li>只做必要的微服务治理</li>
</ol>
<p>第一条定下了此次改造的基调，降低了方案无法落地的风险，确保了项目的整体可行性。第二条让我们站在巨人的肩膀上，不重复造轮子，聚焦在问题本身，而不是工具。第三条缩减项目范围，避免过度工程，以战养兵，不打无用之仗。</p>
<h2 id="2-微服务简介"><a href="#2-微服务简介" class="headerlink" title="2 微服务简介"></a>2 微服务简介</h2><h3 id="3个关键词"><a href="#3个关键词" class="headerlink" title="3个关键词"></a>3个关键词</h3><p>有关微服务的定义，最权威的版本莫属微服务之父Martin Fowler在<a href="http://martinfowler.com/microservices/" target="_blank" rel="external">microservices</a>一文中所述：</p>
<blockquote>
<p>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. – James Lewis and Martin Fowler</p>
</blockquote>
<p>注意其中有3个关键词，small，independently deployable和automated deployment。small对应的就是微服务的微，很多初次接触微服务的同学对微的理解往往会停留在实现层面，以为代码少就是微，但实际上，这里的微更多的是体现在逻辑层面。微服务的一个重要设计原则是share as little as possible，什么意思呢？就是说每个微服务应该设计成边界清晰不重叠，数据独享不共享，也就是我们常说的高内聚、低耦合。保证了small，才能做到independently deployable。而实现automated deployment的关键是DevOps文化，可参见Fowler另一篇谈<a href="http://martinfowler.com/bliki/DevOpsCulture.html" target="_blank" rel="external">DevOps</a>的文章。</p>
<p>需要提醒的是，随着业务复杂度的上升，一个微服务可能需要拆分为更多更细粒度的微服务，比方说，一开始只是一个简单的订单服务，后面逐步拆分出清算，支付，结算，对账等其他服务。</p>
<h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><p>与单体应用拆分为微服务的过程类似，随着公司规模的不断扩大，一个组织势必会分化出多个更小的组织。根据康威定律，组织结构决定系统结构，因此，从这个层面来说，微服务也是一种必然。</p>
<blockquote>
<p>康威定律（Conway’s Law）：“Any organization that design a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. - Melvin Conway, 1968</p>
</blockquote>
<p><img src="conway.png" alt=""></p>
<h3 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a>取舍</h3><p>从本质上来看，相对单体应用，微服务是以牺牲强一致性、提高部署复杂性为代价，换取更彻底的分布式特性，比如异构性和强隔离性。对应CAP理论，就是用Consistency换Partition。异构性比较容易理解，通过定义统一的API规范（一般采用REST风格），每个微服务团队可以根据各自的能力矩阵选用最适合的技术栈，而不是所有人必须使用相同的技术栈。强隔离性指的是，对于一个典型的单体应用，隔离性最高只能体现到模块级别，由于共享同一个代码仓库，模块的边界往往比较模糊，需要人为定义很多规范来保证良好的隔离性，但无论如何强调，稍一疏忽，就会产生“越界”行为，时间愈长，维护隔离性的成本愈高。而到了微服务阶段，自带应用级别的隔离性，“越界”的成本大大提升，无需任何规范，架构本身就保证了隔离性。</p>
<p>另一方面，由于采用了分布式架构，微服务无法再简单的通过数据库事务来保证强一致性，而是通过消息中间件或者某种事务补偿机制来保证最终一致性，比如微信朋友圈的点赞，淘宝订单的物流状态。其次，在微服务阶段，随着应用数量的激增，一次发布往往涉及多个应用，加上异构性带来的部署方式的多样性，对团队的运维水平尤其是自动化水平提出了更高的要求，运维和开发的边界进一步模糊。</p>
<p><img src="http://martinfowler.com/bliki/images/microservicePrerequisites/sketch.png" alt=""></p>
<h3 id="领域知识"><a href="#领域知识" class="headerlink" title="领域知识"></a>领域知识</h3><p>除了组织架构和技术取舍，领域知识是另一个非常重要的决策因素。对于不熟悉的业务领域，很难第一次就把各个微服务的边界和接口定义正确，一旦开始开发，重构成本就会非常可观。反过来说，当对领域知识有了一定的积累，再重构一个单体应用就会容易的多。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综上所述，虽然微服务看上去很美，但在决定采用微服务架构之前，不仅要仔细考量团队的技术水平（包括知识结构，理论深度，经验积累和技术氛围），还应综合考虑项目的时间范围，领域知识的熟悉程度，以及所在组织的规模架构。除非这些前提条件都满足，否则单体应用是更适合的选择，就像Fowler<a href="http://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="external">建议</a>的那样。</p>
<p><img src="http://martinfowler.com/bliki/images/microservice-verdict/path.png" alt=""></p>
<h2 id="3-微服务化总览"><a href="#3-微服务化总览" class="headerlink" title="3 微服务化总览"></a>3 微服务化总览</h2><p><img src="microservice.png" alt=""></p>
<p>上图是XR微服务化第一阶段的整体架构图。可以看到，一些支撑微服务的必要组件都已包含其中：</p>
<ul>
<li>服务注册中心：所有服务注册到Consul集群，集成Nginx实现负载均衡，使用Hystrix实现简单的服务降级和熔断机制</li>
<li>CI/CD：利用<a href="http://emacoo.cn/devops/jenkins-pipeline-tips">Jenkins Pipeline</a>实现<a href="http://emacoo.cn/devops/ci-cd-hot-deployment">不停机发布</a></li>
<li>日志平台：扩展ELK加上Redis缓存</li>
<li>配置中心：使用自研的<a href="https://zybuluo.com/emac/note/241756" target="_blank" rel="external">Matrix</a>系统，最小化对已有应用的侵入性，保证异构系统的兼容性</li>
<li>授权中心：基于Spring Security OAuth，同时支持SSO</li>
<li>消息中心：选用RabbitMQ作为消息中间件</li>
<li>监控平台：利用Consul API获取服务状态，通过Zookeeper触发告警</li>
</ul>
<p>在微服务化系列的后续文章中，我会针对服务注册、配置中心和授权中心分别展开介绍实施过程中的一些细节和经验。敬请期待。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://martinfowler.com/microservices/" target="_blank" rel="external">Microservices Resource Guide</a></li>
<li><a href="http://slides.com/emacooshen/soa/#/" target="_blank" rel="external">企业基础架构浅析</a></li>
<li><a href="http://callistaenterprise.se/blogg/teknik/2015/03/25/an-operations-model-for-microservices/" target="_blank" rel="external">An operations model for Microservices</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=407641457&amp;idx=1&amp;sn=183d27056f3bd8ef17e77a3c15dfb3dd" target="_blank" rel="external">实施微服务，我们需要哪些基础框架？</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw%3D%3D&amp;from=timeline&amp;idx=1&amp;isappinstalled=0&amp;mid=411129391&amp;scene=2&amp;sn=ebf06fb5cc4a5f57f86341ba4114cab8&amp;srcid=0409K1M3NlgPnoCzUXN8wiFP" target="_blank" rel="external">架构的本质是管理复杂性，微服务本身也是架构演化的结果</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA4MzQ1NjQ5Nw%3D%3D&amp;idx=1&amp;mid=402005063&amp;sn=6b714f647c29afb15598a1ca3dbd78c2" target="_blank" rel="external">应用架构一团糟？如何将单体应用改造为微服务</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzIwMjE5MDU4OA==&amp;mid=2653119912&amp;idx=1&amp;sn=d3b08b362de3d895fe0a088dcdc2380c&amp;scene=23&amp;srcid=0806PBMw9lhxnOpEJhLYuvCC#rd" target="_blank" rel="external">一个值得参考的服务化体系改造案例</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;idx=1&amp;mid=2650993889&amp;scene=0&amp;sn=3d8edd0fa55be53d85235212be3a9505" target="_blank" rel="external">华为实施微服务架构的五大军规</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Java进阶】利用APT优雅的实现统一日志格式]]></title>
      <url>http://emacoo.cn/coding/java-apt-logging/</url>
      <content type="html"><![CDATA[<h2 id="统一日志格式的几种方式"><a href="#统一日志格式的几种方式" class="headerlink" title="统一日志格式的几种方式"></a>统一日志格式的几种方式</h2><p>无论是搭建日志平台还是进行大数据分析，统一日志格式都是一个重要的前提条件。假设要统一成下面的日志格式，</p>
<blockquote>
<p>日志格式：[{系统}|{模块}]{描述}[param1=value1$param2=value2]，例如：[API|Weixin]Weixin send message failed. [senderId=1234$receiverId=5678]</p>
</blockquote>
<p>常见的方法有：</p>
<ul>
<li>方法1：每次记录日志时，根据上下文在原始的消息内容前后分别加上合适的[{系统}|{模块}]前缀和参数后缀。</li>
<li>方法2：自定义日志类，将{系统}和{模块}作为构造函数的参数传入，并且在所提供的日志接口中自动格式化传入的参数数组。</li>
<li>方法3：自定义注解类声明所属的{系统}和{模块}，然后通过AOP的方式，统一在日志中插入[{系统}|{模块}]前缀。</li>
<li>方法4：在方法2的基础上，自定义注解类声明所属的{系统}和{模块}，然后通过APT自动生成自定义类型的log成员变量。</li>
</ul>
<p>方法1依赖于人工来保证统一的日志格式，方法3虽然简化了方法调用，但对性能有一定的影响。方法2是最常见的手段，但每个类都要显示声明log成员变量，略显冗余。方法4兼具方法2和方法3的优点，同时又避免了两者的不足，是一种优雅的实现方式，也是<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">lombok</a>所采用的方式。</p>
<p>下面就针对方法4，结合示例代码介绍一下相关技术。</p>
<h2 id="APT-编译期自动生成log成员变量"><a href="#APT-编译期自动生成log成员变量" class="headerlink" title="APT: 编译期自动生成log成员变量"></a>APT: 编译期自动生成log成员变量</h2><p><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/apt/" target="_blank" rel="external">APT</a>的全称是Annotation Processing Tool，诞生于Java 6版本，主要用于在编译期根据不同的注解类生成或者修改代码。APT运行于独立的JVM进程中（编译之前），并且在一次编译过程中可能会被多次调用。</p>
<p>首先，声明一个包含{系统}和{模块}定义的日志注解类。注意@Retention应设置为RetentionPolicy.SOURCE，表示编译后擦除该注解信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于自动生成log成员变量.仅适用于class或enum,不适用于接口.</div><div class="line"> */</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Slf4j &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 系统名称.如果为空则取"-Dvlogging.system"系统属性,如果系统属性也为空,则取"Unknown".</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">system</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模块名称.如果为空则取"-Dvlogging.module"系统属性,如果系统属性也为空,则取"Unknown".</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，声明一个注解处理类，继承Java默认提供的AbstractProcessor类，其中：</p>
<ul>
<li>messager: 用于记录处理日志</li>
<li>trees: 用于解析Java AST树</li>
<li>maker: 用于生成Java AST节点</li>
<li>names: 用于生成Java AST节点名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(processingEnv);</div><div class="line">        messager = processingEnv.getMessager();</div><div class="line">        trees = Trees.instance(processingEnv);</div><div class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</div><div class="line">        maker = TreeMaker.instance(context);</div><div class="line">        names = Names.instance(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在process方法中调用Java Compiler API根据注解信息动态生成log日志成员变量：<br><br><code>private static final Logger log = LoggerFactory.getLogger(LoggerFactory.Type.SLF4J, annotatedClass.class, system, module);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1 检查类型</span></div><div class="line">    roundEnv.getElementsAnnotatedWith(Slf4j.class).stream().forEach(elm -&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (elm.getKind() != ElementKind.CLASS &amp;&amp; elm.getKind() != ElementKind.ENUM) &#123;</div><div class="line">            messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Only classes or enums can be annotated with "</span> + Slf4j.class.getSimpleName());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 2 检查log成员变量是否已存在</span></div><div class="line">        TypeElement typeElm = (TypeElement) elm;</div><div class="line">        <span class="keyword">if</span> (typeElm.getEnclosedElements().stream()</div><div class="line">                .filter(e -&gt; e.getKind() == ElementKind.FIELD &amp;&amp; Logger.FIELD_NAME.equals(e.getSimpleName())).count() &gt; <span class="number">0</span>) &#123;</div><div class="line">            messager.printMessage(Diagnostic.Kind.WARNING, MessageFormat.format(<span class="string">"A member field named &#123;0&#125; already exists in the annotated class"</span>, Logger.FIELD_NAME));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 3 注入log成员变量</span></div><div class="line">        CompilationUnitTree cuTree = trees.getPath(typeElm).getCompilationUnit();</div><div class="line">        <span class="keyword">if</span> (cuTree <span class="keyword">instanceof</span> JCTree.JCCompilationUnit) &#123;</div><div class="line">            JCTree.JCCompilationUnit cu = (JCTree.JCCompilationUnit) cuTree;</div><div class="line">            <span class="comment">// only process on files which have been compiled from source</span></div><div class="line">            <span class="keyword">if</span> (cu.sourcefile.getKind() == JavaFileObject.Kind.SOURCE) &#123;</div><div class="line">                _findType(cu, typeElm.getQualifiedName().toString()).ifPresent(type -&gt; &#123;</div><div class="line">                    Slf4j slf4j = typeElm.getAnnotation(Slf4j.class);</div><div class="line">                    String system = slf4j.system();</div><div class="line">                    String <span class="keyword">module</span> = slf4j.<span class="keyword">module</span>();</div><div class="line"></div><div class="line">                    <span class="comment">// 生成private static final Logger log = LoggerFactory.getLogger(LoggerFactory.Type.SLF4J, &lt;annotatedClass&gt;, &lt;system&gt;, &lt;module&gt;);</span></div><div class="line">                    JCTree.JCExpression loggerType = _toExpression(Logger.class.getCanonicalName());</div><div class="line">                    JCTree.JCExpression getLoggerMethod = _toExpression(LoggerFactory.class.getCanonicalName() + <span class="string">".getLogger"</span>);</div><div class="line">                    JCTree.JCExpression typeArg = _toExpression(LoggerFactory.Type.class.getCanonicalName() + <span class="string">"."</span> + LoggerFactory.Type.SLF4J.name());</div><div class="line">                    JCTree.JCExpression nameArg = _toExpression(typeElm.getQualifiedName() + <span class="string">".class"</span>);</div><div class="line">                    JCTree.JCExpression systemArg = maker.Literal(system);</div><div class="line">                    JCTree.JCExpression moduleArg = maker.Literal(<span class="keyword">module</span>);</div><div class="line">                    JCTree.JCMethodInvocation getLoggerCall = maker.Apply(List.nil(), getLoggerMethod, List.of(typeArg, nameArg, systemArg, moduleArg));</div><div class="line">                    JCTree.JCVariableDecl logField = maker.VarDef(</div><div class="line">                            maker.Modifiers(Flags.PRIVATE | Flags.STATIC | Flags.FINAL),</div><div class="line">                            names.fromString(Logger.FIELD_NAME), loggerType, getLoggerCall);</div><div class="line"></div><div class="line">                    _insertField(type, logField);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集成示例"><a href="#集成示例" class="headerlink" title="集成示例"></a>集成示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Slf</span>4j(system = <span class="string">"Vlogging"</span>, <span class="keyword">module</span> = <span class="string">"Integration"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VloggingAnnotated</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        HashMap&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        params.put(<span class="string">"foo"</span>, <span class="string">"xyz"</span>);</div><div class="line">        log.info(VloggingAnnotated.class.getCanonicalName(), params);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，使用方法4，业务类只要加上自定义注解，然后正常调用日志API，就可以以统一的日志格式记录日志。</p>
<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-07-10 17:26:45 +0800 [INFO] from VloggingAnnotated in main - [Vlogging|Integration]com.xingren.v.logging.integration.VloggingAnnotated[foo=xyz]</div></pre></td></tr></table></figure>
<h2 id="IntelliJ-Plugin-自动生成PSI-Element，消除编译错误"><a href="#IntelliJ-Plugin-自动生成PSI-Element，消除编译错误" class="headerlink" title="IntelliJ Plugin: 自动生成PSI Element，消除编译错误"></a>IntelliJ Plugin: 自动生成PSI Element，消除编译错误</h2><p>至此，在命令行方式下，方法4已经可以正确运行。但在IDE环境中（比如IntelliJ，Eclipse），由于一般它们都会使用自定义的编译模型，需要额外实现一个插件来根据注解信息动态修改IDE的语法树，以避免编译错误。对于IntelliJ而言，使用的是<a href="http://www.jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi_elements.html" target="_blank" rel="external">PSI模型</a>，相应的插件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 继承com.intellij.psi.augment.PsiAugmentProvider类</span></div><div class="line"></div><div class="line"><span class="meta">@NotNull</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;Psi extends PsiElement&gt; <span class="function">List&lt;Psi&gt; <span class="title">getAugments</span><span class="params">(@NotNull PsiElement psiElement, @NotNull Class&lt;Psi&gt; type)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> List&lt;Psi&gt; emptyResult = Collections.emptyList();</div><div class="line">    <span class="comment">// skip processing during index rebuild</span></div><div class="line">    <span class="keyword">final</span> Project project = psiElement.getProject();</div><div class="line">    <span class="keyword">if</span> (DumbService.isDumb(project)) &#123;</div><div class="line">        <span class="keyword">return</span> emptyResult;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Expecting that we are only augmenting an PsiClass</span></div><div class="line">    <span class="comment">// Don't filter !isPhysical elements or code auto completion will not work</span></div><div class="line">    <span class="keyword">if</span> (!(psiElement <span class="keyword">instanceof</span> PsiExtensibleClass) || !psiElement.isValid()) &#123;</div><div class="line">        <span class="keyword">return</span> emptyResult;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// filter non-field type</span></div><div class="line">    <span class="keyword">if</span> (!PsiField.class.isAssignableFrom(type)) &#123;</div><div class="line">        <span class="keyword">return</span> emptyResult;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> PsiClass psiClass = (PsiClass) psiElement;</div><div class="line">    <span class="comment">// see AbstractClassProcessor#process()</span></div><div class="line">    PsiAnnotation psiAnnotation = PsiAnnotationUtil.findAnnotation(psiClass, Slf4j.class);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == psiAnnotation) &#123;</div><div class="line">        <span class="keyword">return</span> emptyResult;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// check cache first</span></div><div class="line">    <span class="keyword">if</span> (loggerCache.containsKey(psiClass.getQualifiedName())) &#123;</div><div class="line">        <span class="keyword">return</span> Arrays.asList((Psi) loggerCache.get(psiClass.getQualifiedName()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> PsiManager manager = psiClass.getContainingFile().getManager();</div><div class="line">    <span class="keyword">final</span> PsiElementFactory psiElementFactory = JavaPsiFacade.getElementFactory(project);</div><div class="line">    PsiType psiLoggerType = psiElementFactory.createTypeFromText(LOGGER_TYPE, psiClass);</div><div class="line">    LightFieldBuilder loggerField = <span class="keyword">new</span> LightFieldBuilder(manager, LOGGER_NAME, psiLoggerType);</div><div class="line">    LightModifierList modifierList = (LightModifierList) loggerField.getModifierList();</div><div class="line">    modifierList.addModifier(PsiModifier.PRIVATE);</div><div class="line">    modifierList.addModifier(PsiModifier.STATIC);</div><div class="line">    modifierList.addModifier(PsiModifier.FINAL);</div><div class="line">    loggerField.setContainingClass(psiClass);</div><div class="line">    loggerField.setNavigationElement(psiAnnotation);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String loggerInitializerParameter = String.format(LOGGER_CATEGORY, psiClass.getName());</div><div class="line">    <span class="keyword">final</span> PsiExpression initializer = psiElementFactory.createExpressionFromText(String.format(LOGGER_INITIALIZER, loggerInitializerParameter), psiClass);</div><div class="line">    loggerField.setInitializer(initializer);</div><div class="line">    <span class="comment">// add to cache</span></div><div class="line">    loggerCache.put(psiClass.getQualifiedName(), loggerField);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Arrays.asList((Psi) loggerField);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">GitHub: lombok</a></li>
<li><a href="https://github.com/mplushnikov/lombok-intellij-plugin" target="_blank" rel="external">GitHub: lombok-intellij-plugin</a></li>
<li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="external">ANNOTATION PROCESSING 101</a></li>
<li><a href="https://www.javacodegeeks.com/2015/09/java-compiler-api.html" target="_blank" rel="external">Java Compiler API</a></li>
<li><a href="http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started.html" target="_blank" rel="external">Creating Your First Plugin</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【CI/CD】几种常见的不停机发布方式]]></title>
      <url>http://emacoo.cn/devops/ci-cd-hot-deployment/</url>
      <content type="html"><![CDATA[<h2 id="何为不停机发布？"><a href="#何为不停机发布？" class="headerlink" title="何为不停机发布？"></a>何为不停机发布？</h2><p>本文所说的不停机发布，是指在<strong>不停止对外服务</strong>的前提下完成应用的更新。与<a href="http://emacoo.cn/coding/play-hotdeploy">热部署</a>的区别在于，热部署关注于<strong>应用</strong>层面并且以<strong>不重启应用</strong>为前提，而不停机发布则关注于<strong>服务</strong>层面。随着摩尔定律逐渐逼近极限和多核时代的到来，分布式应用已经成为事实上的主流。下文首先给出一种通用的适用于分布式应用环境的不停机发布方式，然后再介绍Master/Worker这种常见的适用于单机应用的不停机发布方式。</p>
<h2 id="Cluster模式"><a href="#Cluster模式" class="headerlink" title="Cluster模式"></a>Cluster模式</h2><p>对于运行于集群环境的分布式应用，一般在应用之上都有一层负载均衡（LB）。如果在发布过程中，在更新任一节点（也可以是一组节点）前先关闭该节点对应的负载，更新完再打开负载，即可实现整体服务的不停机发布。在此基础上，为了保证服务的稳定性，可以加上备机的支持，即更新某一节点时，先挂上备机，更新完再卸下，依次轮换更新完所有节点后最后再升级备机，如下图所示：</p>
<p><img src="http://static.zybuluo.com/emac/zijlzk2pruasmrbmbaz8eev1/QQ20160405-3.png" alt=""></p>
<p><em>* 完整设计可以参考我写的另一篇<a href="https://www.zybuluo.com/emac/note/330205" target="_blank" rel="external">文章</a></em></p>
<p>上述发布过程其实就是一个简单的CD（Continuous Deployment）系统。作为一个参考实现，可以使用<a href="http://emacoo.cn/devops/jenkins-2-0-from-ci-to-cd">Jenkins 2.0 Pipeline</a>特性定义整个发布流程，使用<a href="https://github.com/cubicdaiya/ngx_dynamic_upstream" target="_blank" rel="external">Nginx Dynamic Upstream</a>插件操纵Nginx，然后配合脚本完成应用的启停和检测。</p>
<p><img src="QQ20160609-0.png" alt=""></p>
<h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master/Worker模式"></a>Master/Worker模式</h2><p>对于单机应用，由于不存在LB，一般由应用容器实现不停机发布特性，最常见是Master/Worker模式。容器中常驻一个master进程和多个work进程，master进程只负责加载程序和分发请求，由fork出来的worker进程完成具体工作。当容器收到更新应用的信号时，master进程重新加载更新后的程序，然后fork新的worker进程处理新的请求，而老的worker进程在处理完当前请求后就自动销毁。Ruby的<a href="https://github.com/blog/517-unicorn" target="_blank" rel="external">Unicorn</a>，PHP的<a href="http://php-fpm.org/about/" target="_blank" rel="external">FPM</a>都是采用了这套机制。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>不同于Master/Worker模式，erlang采用了另一种独特的方式实现了不停机发布。</p>
<blockquote>
<p>erlang VM为每个模块最多保存2份代码，当前版本’current’和旧版本’old’，当模块第一次被加载时，代码就是’current’版本。如果有新的代码被加载，’current’版本代码就变成了’old’版本，新的代码就成了’current’版本。erlang用两个版本共存的方法来保证任何时候总有一个版本可用，对外服务就不会停止。<br><br><br>—— 引自<a href="http://blog.csdn.net/mycwq/article/details/43372687" target="_blank" rel="external">分析erlang热更新实现机制</a></p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不管是LB，还是Master/Worker，其基本思想都是在发布过程中，通过某种机制使得服务请求始终能够被系统的某个节点或者某个进程处理，从而保证了服务的可用性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Jenkins】Pipeline使用进阶]]></title>
      <url>http://emacoo.cn/devops/jenkins-pipeline-tips/</url>
      <content type="html"><![CDATA[<h2 id="无所不能，无所不及的Pipeline"><a href="#无所不能，无所不及的Pipeline" class="headerlink" title="无所不能，无所不及的Pipeline"></a>无所不能，无所不及的Pipeline</h2><p>得益于Jenkins内嵌的Groovy支持，加上<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="external">丰富的Step库</a>，通过编写自定义Pipeline脚本你几乎可以实现任何复杂的构建、发布流程。下面简单谈谈使用Pipeline的四个段位。</p>
<h2 id="I-启蒙老师：Snipper-Generator"><a href="#I-启蒙老师：Snipper-Generator" class="headerlink" title="I. 启蒙老师：Snipper Generator"></a>I. 启蒙老师：Snipper Generator</h2><p>Jenkins晦涩的行文风格并没有随着2.0的发布有所改善，Step库的<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="external">官方参考手册</a>成功的延续了Jenkins一贯的惜字如金风格，大多数Step都只有一句话的描述和一些参数类型，罕有使用样例，比如<a href="https://jenkins.io/doc/pipeline/steps/workflow-scm-step/#git-git" target="_blank" rel="external">Git Step</a>。要理解这些Step，基本靠脑补。好在Jenkins提供了一款良心产品，<a href="https://jenkins.io/doc/pipeline/#using-snippet-generator" target="_blank" rel="external">Snipper Generator</a>，帮助使用者在Pipeline配置界面3步生成正确的调用语句。</p>
<p><img src="QQ20160522-0.png" alt=""></p>
<h2 id="II-调试利器：Replay-Pipeline"><a href="#II-调试利器：Replay-Pipeline" class="headerlink" title="II. 调试利器：Replay Pipeline"></a>II. 调试利器：Replay Pipeline</h2><p>维护过CI的同学一定知道，在成功创建一个正确、稳定运行的CI任务之前，往往需要历经多次调试和优化，创建Pipeline更是如此。为了避免重复打开配置界面调整Pipeline脚本，Jenkins贴心的提供了<a href="https://jenkins.io/blog/2016/04/14/replay-with-pipeline/" target="_blank" rel="external">Replay</a>功能。打开任意一次执行历史，在左侧点击Replay按钮，即可复原该次执行所运行的Pipeline脚本，无论脚本来源是任务本身还是远程仓库。</p>
<p><img src="QQ20160522-1.png" alt=""></p>
<h2 id="III-隐藏秘籍：Workflow-Global-Library"><a href="#III-隐藏秘籍：Workflow-Global-Library" class="headerlink" title="III. 隐藏秘籍：Workflow Global Library"></a>III. 隐藏秘籍：Workflow Global Library</h2><p>很多人不知道，Jenkins默认会启动一个SSHD服务，用于在<a href="https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+CLI" target="_blank" rel="external">CLI</a>方式下执行一些Jenkins命令。Jenkins 2.0在此基础上，绑定了一个本地Git库（Workflow Global Library，简称WGL），用于上传一些全局共享的Groovy脚本，供同一Jenkins实例下所有Pipeline脚本调用。具体使用步骤如下：</p>
<ol>
<li><p>进入系统配置界面，找到SSH Server配置项，指定一个固定的SSH端口。<br><img src="QQ20160522-2.png" alt=""></p>
</li>
<li><p>进入当前用户的配置页面，绑定SSH Public Key。<br><img src="QQ20160522-3.png" alt=""></p>
</li>
<li><p>打开命令行，运行<code>git clone ssh://&lt;user&gt;@&lt;host&gt;:&lt;port&gt;/workflowLibs.git</code>拉取WGL。</p>
</li>
<li>在Git库的根目录下创建vars目录，编写Groovy脚本并存放于此，提交代码并Push至远程库。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hello.groovy，一个简单的示例Groovy脚本，定义了一个名为hello的全局方法</span></div><div class="line"><span class="keyword">def</span> call(name) &#123;</div><div class="line">    echo <span class="string">"Hello, $&#123;name&#125;!"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IV-如来神掌：Jenkins-Plugin"><a href="#IV-如来神掌：Jenkins-Plugin" class="headerlink" title="IV. 如来神掌：Jenkins Plugin"></a>IV. 如来神掌：Jenkins Plugin</h2><p>如果你需要同时维护多个Jenkins实例，那么WGL就不再适用了，因为每一个Jenkins实例你都需要上传一份脚本。这时就要祭出Jenkins Plugin大法，也即将共享的Groovy脚本封装到一个自定义Jenkins Plugin中，然后安装到需要的Jenkins实例中，以后也可以进行统一升级，有效降低了维护成本。要实现这一点，除了<a href="https://wiki.jenkins-ci.org/display/JENKINS/Extend+Jenkins" target="_blank" rel="external">传统的定义Jenkins Plugin的方法</a>，Jenkins<a href="https://jenkins.io/blog/2016/04/21/dsl-plugins/" target="_blank" rel="external">官方博客</a>还提供了另一种更为简便的封装方式，具体可以参考我的这个GitHub项目，<a href="https://github.com/emac/demo-pipeline-step" target="_blank" rel="external">demo-pipeline-step</a>。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>利用强大、灵活的Pipeline，我们可以像组装乐高玩具一般操纵Jenkins，根据实际情况构建所需的CI/CD流程。近期我设计的<a href="https://zybuluo.com/emac/note/330205" target="_blank" rel="external">Frigate</a>发布系统正式利用Jenkins Pipeline无缝衔接各个发布环节。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://jenkins.io/blog/2016/04/14/replay-with-pipeline/" target="_blank" rel="external">Replay a Pipeline with script edits</a></li>
<li><a href="https://jenkins.io/blog/2016/04/21/dsl-plugins/" target="_blank" rel="external">Making your own DSL with plugins, written in Pipeline script</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Jenkins】2.0新时代：从CI到CD]]></title>
      <url>http://emacoo.cn/devops/jenkins-2-0-from-ci-to-cd/</url>
      <content type="html"><![CDATA[<h2 id="2-0-破茧重生"><a href="#2-0-破茧重生" class="headerlink" title="2.0 破茧重生"></a>2.0 破茧重生</h2><p>自从去年9月底Jenkins的创始人<a href="https://github.com/kohsuke" target="_blank" rel="external">Kohsuke Kawaguchi</a>提出Jenkins 2.0（后称2.0）的<a href="https://docs.google.com/presentation/d/12ikbbQoMvus_l_q23BxXhYXnW9S5zsVNwIKZ9N8udg4/edit#slide=id.p" target="_blank" rel="external">愿景</a>和<a href="https://groups.google.com/forum/#!topic/jenkinsci-dev/vbXK7JJekFw/overview" target="_blank" rel="external">草案</a>之后，整个Jenkins社区为之欢欣鼓舞，不管是官方博客还是Google论坛，大家都在热烈讨论和期盼2.0的到来。4月20日，历经Alpha(2/29)，Beta(3/24)，RC(4/7)3个版本的迭代，2.0终于正式发布。这也是Jenkins面世11年以来（算上前身Hudson）的首次大版本升级。那么，这次升级具体包含了哪些内容呢？</p>
<h3 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h3><p>从外部来看，2.0最大的三个卖点分别是Pipeline as Code，全新的开箱体验和1.x兼容性。</p>
<p><strong>Pipeline as Code</strong>是2.0的精髓所在，是帮助Jenkins实现CI(Continuous Integration)到CD(Continuous Delivery)华丽转身的关键推手。所谓Pipeline，简单来说，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程（例如下图）。Pipeline的实现方式是一套Groovy DSL(类似Gradle)，任何发布流程都可以表述为一段Groovy脚本，并且Jenkins支持从代码库直接读取脚本，从而实现了Pipeline as Code的理念。</p>
<p><img src="https://jenkins.io/images/pipeline/realworld-pipeline-flow.png" alt=""></p>
<p><strong>全新的开箱体验</strong>力图扭转我们印象中Jenkins十年不变的呆滞界面风格，不光Jenkins应用本身，官网排版、博客样式乃至域名都被重新设计。这些变化除了极大的改善了用户体验，更重要的是给人们传达一个清晰的信号，Jenkins不再仅仅是一个CI工具，而是蕴含着无限可能。</p>
<p><img src="https://jenkins.io/images/2.0-create-item.png" alt=""></p>
<p><img src="https://jenkins.io/images/2.0-config-dialog.png" alt=""></p>
<p><strong>1.x兼容性</strong>给所有老版本用户吃了一颗大大的定心丸，注意，是完全兼容哦。</p>
<h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><p>从内部来看，2.0主要包含了一些组件升级和JS模块化改造。</p>
<ul>
<li>升级Servlet版本到3.1，获取Web Sockets支持</li>
<li>升级内嵌的Groovy版本到2.4.6<ul>
<li>未来版本的Jenkins将会<a href="https://issues.jenkins-ci.org/browse/JENKINS-29068" target="_blank" rel="external">把Groovy彻底从内核中剥离</a>，此次Groovy升级只是第一步</li>
</ul>
</li>
<li>提供一个简化的JS类库给Plugin开发者使用</li>
</ul>
<h3 id="更好的容器化支持"><a href="#更好的容器化支持" class="headerlink" title="更好的容器化支持"></a>更好的容器化支持</h3><p>随着容器化技术（以Docker为代表）的不断升温，Jenkins紧随潮流，不仅同步上传2.0的Docker镜像，同时也在Pipeline中提供了默认的<a href="https://jenkins.io/doc/pipeline/steps/docker-workflow/" target="_blank" rel="external">Docker支持</a>。</p>
<p>除了上述内容，2.0还有一个比较有意思的改动，全局重命名Slave为Agent，看来在美国做IT政治正确性也是很重要啊。</p>
<h2 id="Pipeline-as-Code"><a href="#Pipeline-as-Code" class="headerlink" title="Pipeline as Code"></a>Pipeline as Code</h2><p>了解了2.0的概貌之后，回过来我们再看一下Pipeline as Code(后称Pipeline)产生的背景和具体构成。</p>
<h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>作为2.0的核心插件，Pipeline并不是一个新事物，它的前身是<a href="https://wiki.jenkins-ci.org/display/JENKINS/Workflow+Plugin" target="_blank" rel="external">Workflow Plugin</a>，而Workflow的诞生是受更早的<a href="https://wiki.jenkins-ci.org/display/JENKINS/Build+Flow+Plugin" target="_blank" rel="external">Build Flow Plugin</a>启发，由<a href="https://github.com/ndeloof" target="_blank" rel="external">Nicolas De Loof</a>于2012年4月发布第一个版本。而纵观Jenkins的几个竞争对手（<a href="https://docs.travis-ci.com/user/customizing-the-build/" target="_blank" rel="external">Travis CI</a>、<a href="https://www.phptesting.org/wiki/Adding-PHPCI-Support-to-Your-Projects" target="_blank" rel="external">phpci</a>、<a href="https://circleci.com/docs/configuration/" target="_blank" rel="external">circleci</a>），Pipeline早已不是什么新鲜概念。可以说这次Jenkins 2.0的发布是顺势而为，同时也是大势所趋。</p>
<p>如果要在更大范围探讨Pipelined的产生背景，我认为有三个层面的原因。</p>
<ul>
<li>第一层面，与不断增长的发布复杂度有关，其中一个典型场景就是灰度发布。原本只有大公司才有的灰度发布，随着敏捷开发实践的广泛采用、产品迭代周期的不断缩短、数据增长理念的深入人心，越来越多的中小公司也开始这一方面的探索，这对发布的需求也从点状的CI升级到线状的CD。这是Pipeline产生的第一个原因。</li>
<li>第二层面，与应用架构的模块化演变有关，以<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">微服务</a>为代表，一次应用升级往往涉及到多个模块的协同发布，单个CI显然无法满足此类需求。这是Pipeline产生的第二个原因。</li>
<li>第三层面，与日益失控的CI数量有关。一方面，类似于Maven、pip、RubyGems这样的包管理工具使得有CI需求的应用呈爆发性增长，另一方面，受益于便捷的Git分支特性，即便对于同一个应用，往往也需要配置多个CI。随着CI数量的不断增长，集中式的任务配置就会成为一个瓶颈，这就需要把任务配置的职责下放到应用团队。这是Pipeline(as Code)产生的第三个原因。</li>
</ul>
<h3 id="具体构成"><a href="#具体构成" class="headerlink" title="具体构成"></a>具体构成</h3><p>说完背景，再看一下Pipeline的具体构成和特性。</p>
<p>基本概念：</p>
<ul>
<li>Stage: 一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。</li>
<li>Node: 一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行期环境。</li>
<li>Step: Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供。</li>
</ul>
<p>具体构成：</p>
<ul>
<li>Jenkinsfile: Pipeline的定义文件，由Stage，Node，Step组成，一般存放于代码库根目录下。</li>
<li>Stage View: Pipeline的视觉展现，类似于下图。</li>
</ul>
<p><img src="QQ20160502-0.png" alt=""></p>
<p>2.0默认支持三种类型的Pipeline，普通Pipeline，Multibranch Pipeline和Organization Folders，后两种其实是批量创建一组普通Pipeline的快捷方式，分别对应于多分支的应用和多应用的大型组织。注意，要获取Organization Folders的支持需要额外安装Plugin。</p>
<p>值得一提的是，2.0有两个很重要的特性：</p>
<ul>
<li>Pausable: 类似于Bash的read命令，2.0允许暂停发布流程，等待人工确认后再继续，这个特性对于保证应用HA尤为重要。</li>
</ul>
<p><img src="QQ20160502-1.png" alt=""></p>
<ul>
<li>Durable: 发布过程中，如果Jenkins挂掉，正在运行中的Pipeline并不会受影响，也就是说Pipeline的进程独立于Jenkins进程本身。</li>
</ul>
<h3 id="示例Pipeline"><a href="#示例Pipeline" class="headerlink" title="示例Pipeline"></a>示例Pipeline</h3><p>上文所涉及的示例Pipeline可以在我的<a href="(https://github.com/emac/pagination/blob/master/Jenkinsfile">GitHub</a>)找到，如果有问题想跟我探讨，可以加我QQ: 7789059。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://jenkins.io/blog/2016/04/15/the-need-for-pipeline/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+ContinuousBlog+%28Jenkins%29" target="_blank" rel="external">The Need for Jenkins Pipeline</a></li>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+2.0" target="_blank" rel="external">Jenkins 2.0</a></li>
<li><a href="https://github.com/jenkinsci/pipeline-plugin/blob/master/TUTORIAL.md" target="_blank" rel="external">Why Pipeline?</a></li>
<li><a href="https://jenkins.io/blog/2015/12/03/pipeline-as-code-with-multibranch-workflows-in-jenkins/" target="_blank" rel="external">Pipeline-as-code with Multibranch Workflows in Jenkins</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】基于Spring Data JPA的分页组件]]></title>
      <url>http://emacoo.cn/backend/spring-data-jpa-pagination/</url>
      <content type="html"><![CDATA[<h2 id="分页的基本模型"><a href="#分页的基本模型" class="headerlink" title="分页的基本模型"></a>分页的基本模型</h2><p>做Web应用开发，或早或晚都会涉及到分页。按模型划分，分页包含页码（page），大小（size）和总条数（count），页码和大小面向的是前端页面，而总条数来自后端服务。按表现形式，可分为显式分页和隐式分页（比如上拉加载），显示分页一般用于PC端，而隐式分页一般用于Mobile端。按实现方式，或者由前端JS生成，或者是后端模板。</p>
<h2 id="分页的基本原理"><a href="#分页的基本原理" class="headerlink" title="分页的基本原理"></a>分页的基本原理</h2><p>一般而言，分页最终都是映射到数据库查询，在此场景下，不论何种分页框架，其基本原理都是基于SQL的<code>LIMIT [offset,] row_count</code>语法（数据库不同语法略有差别）。row_count对应的是size，而offset则是通过page*size计算得到（假设page从0计数），比如(page=1, size=10)对应(offset=10, row_count=10)。</p>
<p>介绍了分页的基本模型和原理后，接下来我结合一个基于Spring Data JPA的分页组件，阐述分页的一些实现要点。</p>
<h2 id="分页的实现要点"><a href="#分页的实现要点" class="headerlink" title="分页的实现要点"></a>分页的实现要点</h2><p>首先看一个典型的分页效果：</p>
<p><img src="pagination.png" alt="pagination"></p>
<p>整个分页组件由三部分组成，首页|上一页，下一页|末页，以及中间的页码组。显然，前两部分是固定的，而页码组是随着当前页码的变化而变化。其实现要点有三个，</p>
<ul>
<li>计算页码组：首先比较页码组默认长度和总页数，取较小值为页码组最终长度（L）。然后根据当前页码（P）和总页数（T）的关系，再细分为三种情况<ul>
<li>P+L/2&lt;=L: 页码组从1开始计数，比如(P=2, T=6, L=5) -&gt; 1,2,3,4,5</li>
<li>P+L&gt;=T: 页码组从T倒数L开始计数，比如(P=5, T=6, L=5) -&gt; 2,3,4,5,6</li>
<li>其他: 页码组从P-L/2+1开始计数，比如(P=4, T=6, L=5) -&gt; 2,3,4,5,6</li>
</ul>
</li>
<li>按钮状态：首页，上一页，下一页，末页对应按钮的启用状态应随当前页码的值变化而变化，并且当前页码对应的按钮应该始终处于禁用状态。</li>
<li>页码显示：页面显示是从1开始，而数据库查询是从0开始。这一点不想清楚，边界情况就处理不好。</li>
</ul>
<p>具体实现细节，可参考我GitHub的一个示例项目，<a href="https://github.com/emac/pagination" target="_blank" rel="external">Pagination</a>。</p>
<h2 id="Spring-Data-JPA简介"><a href="#Spring-Data-JPA简介" class="headerlink" title="Spring Data JPA简介"></a>Spring Data JPA简介</h2><p><a href="http://projects.spring.io/spring-data-jpa/" target="_blank" rel="external">Spring Data JPA</a>隶属于<a href="http://projects.spring.io/spring-data/" target="_blank" rel="external">Spring Data</a>项目，通过一系列Spring风格的接口和注解，极大的简化了创建和开发JPA Repository的过程，同时提供了自定义查询，分页排序等高级特性的支持。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://docs.spring.io/spring-data/commons/docs/current/reference/html/" target="_blank" rel="external">Spring Data Commons - Reference Documentation</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】单应用多数据库的事务管理]]></title>
      <url>http://emacoo.cn/backend/spring-transaction/</url>
      <content type="html"><![CDATA[<h2 id="单应用多数据库的事务管理"><a href="#单应用多数据库的事务管理" class="headerlink" title="单应用多数据库的事务管理"></a>单应用多数据库的事务管理</h2><p><a href="http://emacoo.cn/backend/spring-boot-multi-db">上篇</a>讲到单应用多数据库的配置，这次我们聊聊单应用多数据库的事务管理。首先我们来了解一下事务。</p>
<h2 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h2><blockquote>
<p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。<br><a href="http://baike.baidu.com/view/1298364.htm" target="_blank" rel="external">http://baike.baidu.com/view/1298364.htm</a></p>
</blockquote>
<p>举个栗子，银行的一次转账操作就可以理解成一个事务，A打钱给B，银行首先从A的账户里扣钱，然后把钱转到B的账户。如果只执行前一步，A肯定不乐意，如果是后一步，换银行不乐意。所以两步要么都执行，要么都不执行。</p>
<h2 id="单库事务和跨库事务有什么区别？"><a href="#单库事务和跨库事务有什么区别？" class="headerlink" title="单库事务和跨库事务有什么区别？"></a>单库事务和跨库事务有什么区别？</h2><p>一般而言，所谓的数据库事务都是针对单个数据库的事务，即单库事务。而跨库事务，顾名思义，是指涉及多个数据库的事务，理论上也必须满足ACID属性。两者最核心的区别在于，单库事务一般是由数据库保证的，俗称物理事务，而跨库事务一般是由应用保证的，俗称逻辑事务。与单库事务相比，跨库事务执行成本高，稳定性差，管理也更复杂，但在某些场景下，尤其是分布式应用环境下，又是不得不使用的技术。</p>
<p>再举个栗子，单库事务好比你从北京飞上海，到东航官网买张票就搞定了，而跨库事务好比北京飞纽约，到上海转机，就得买东航转上航的联票，出票就转由携程保证了。</p>
<h2 id="多数据库下的三种事务使用场景"><a href="#多数据库下的三种事务使用场景" class="headerlink" title="多数据库下的三种事务使用场景"></a>多数据库下的三种事务使用场景</h2><p>了解了单库事务和跨库事务之后，我们再来看看多数据库下的三种事务使用场景。假设有DB1，DB2两个数据库，分别对应ServiceA和ServiceB两个带上事务注解的服务类，根据调用关系，可细分为三种场景。</p>
<h3 id="场景一：仅调用ServiceA，ServiceA不调用ServiceB"><a href="#场景一：仅调用ServiceA，ServiceA不调用ServiceB" class="headerlink" title="场景一：仅调用ServiceA，ServiceA不调用ServiceB"></a>场景一：仅调用ServiceA，ServiceA不调用ServiceB</h3><p>这种情况等同于单库事务，无需特殊处理。</p>
<h3 id="场景二：仅调用ServiceA，ServiceA再调用ServiceB"><a href="#场景二：仅调用ServiceA，ServiceA再调用ServiceB" class="headerlink" title="场景二：仅调用ServiceA，ServiceA再调用ServiceB"></a>场景二：仅调用ServiceA，ServiceA再调用ServiceB</h3><p><img src="QQ20160327-0.png" alt=""></p>
<h3 id="场景三：先调用ServiceA，再调用ServiceB"><a href="#场景三：先调用ServiceA，再调用ServiceB" class="headerlink" title="场景三：先调用ServiceA，再调用ServiceB"></a>场景三：先调用ServiceA，再调用ServiceB</h3><p><img src="QQ20160327-1.png" alt=""></p>
<p>场景二和场景三是两种典型的跨库事务，Spring默认的事务管理并无法保证事务的属性。对于场景二，在调用ServiceB之后，如果ServiceA出错，ServiceB并不会回滚。而对于场景三，在调用ServiceB之前，ServiceA的事务已经完成，因此当ServiceB出错回滚时，ServiceA并不会同步回滚。</p>
<p>如何解决？前面说过，跨库事务一般是由应用保证，因此办法有很多。标准的方法是使用JTA框架进行两段式提交，比如开源的<a href="https://www.atomikos.com/Main/WebHome" target="_blank" rel="external">Atomikos</a>，<a href="https://github.com/bitronix/btm" target="_blank" rel="external">Bitronix</a>。粗暴一点，可以显式创建两个事务，将所有的服务调用包在其中。考虑到本文单应用的环境，还有第三种方式，根据所涉及的事务列表，动态构造调用链，把所有的服务调用封装到最内层，由外层的事务注解链保证跨库事务。</p>
<p>定义事务代理类，每一个类代理一个数据库事务：</p>
<pre><code>@Component
public class Db1TxBroker {
    @Transactional(DbConstants.TX_DB1)
    public &lt;V&gt; V inAccount(Callable&lt;V&gt; callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw new ServiceException(e);
        }
    }
}
</code></pre><p>负责生成调用链的服务基类：</p>
<pre><code>public abstract class BaseComboService {

    @Autowired
    private Db1TxBroker db1TxBroker;

    @Autowired
    private Db2TxBroker db2TxBroker;

    /**
     * 根据传入的事务链构造调用链,在最内层调用包含业务逻辑的callable.
     *
     * @param callable
     * @param txes 所涉及的完整事务列表(顺序无关)
     */
    protected &lt;V&gt; V combine(Callable&lt;V&gt; callable, TX... txes) {
        if (callable == null) {
            return null;
        }

        Callable&lt;V&gt; combined = Stream.of(txes).filter(Objects::nonNull).distinct().reduce(callable, (r, tx) -&gt; {
            switch (tx) {
                case DB1:
                    return () -&gt; db1TxBroker.inDb1(r);
                case DB2:
                    return () -&gt; db2TxBroker.inDb2(r);
                default:
                    // should not happen
                    return null;
            }
        }, (r1, r2) -&gt; r2);
        try {
            return combined.call();
        } catch (Exception e) {
            throw new ServiceException(e);
        }
    }
}
</code></pre><p>使用示例：</p>
<pre><code>@Service
public class DemoComboService extends BaseComboService {

    @Autowired
    private ServiceA serviceA;

    @Autowired
    private ServiceB serviceB;

    public void demo() {
        combine(() -&gt; {
            serviceA.flyToShanghai();
            serviceB.flyToNewYork();
            return null;
        }, TX.DB1, TX.DB2);
    }
}
</code></pre><p>相比JTA，上述第三种方法最大的优点是更轻量，配置更简单，但只能工作在单个应用的环境。对于分布式应用，后者就无能为力了。这种方法本质上还是借助Spring的事务注解来保证跨库事务，如果将来Spring的事务注解支持JDK8的@Repeatable特性，那就可以直接在方法上加上多个事务注解来达到同样目的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://spring.io/blog/2011/08/15/configuring-spring-and-jta-without-full-java-ee/" target="_blank" rel="external">Configuring Spring and JTA without full Java EE</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/1441271" target="_blank" rel="external">Spring的事务之编程式事务</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】Redis的两个典型应用场景]]></title>
      <url>http://emacoo.cn/backend/spring-redis/</url>
      <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p><a href="http://redis.io/" target="_blank" rel="external">Redis</a>是目前业界使用最广泛的内存数据存储。相比memcached，Redis支持更丰富的数据结构，例如hashes, lists, sets等，同时支持数据持久化。除此之外，Redis还提供一些类数据库的特性，比如事务，HA，主从库。可以说Redis兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍Redis在Spring Boot中两个典型的应用场景。</p>
<h2 id="场景1：数据缓存"><a href="#场景1：数据缓存" class="headerlink" title="场景1：数据缓存"></a>场景1：数据缓存</h2><p>第一个应用场景是数据缓存，最典型的当属缓存数据库查询结果。对于高频读低频写的数据，使用缓存可以第一，加速读取过程，第二，降低数据库压力。通过引入spring-boot-starter-redis依赖和注册RedisCacheManager，Redis可以无缝的集成进Spring的缓存系统，自动绑定@Cacheable, @CacheEvict等缓存注解。</p>
<p>引入依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>Redis配置（application.properties）:</p>
<pre><code># REDIS (RedisProperties)
spring.redis.host=localhost
spring.redis.password=
spring.redis.database=0
</code></pre><p>注册RedisCacheManager：</p>
<pre><code>@Configuration
@EnableCaching
public class CacheConfig {

    @Autowired
    private JedisConnectionFactory jedisConnectionFactory;

    @Bean
    public RedisCacheManager cacheManager() {
        RedisCacheManager redisCacheManager = new RedisCacheManager(redisTemplate());
        return redisCacheManager;
    }

    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate() {
        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;Object, Object&gt;();
        redisTemplate.setConnectionFactory(jedisConnectionFactory);
        // 开启事务支持
        redisTemplate.setEnableTransactionSupport(true);
        // 使用String格式序列化缓存键
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setHashKeySerializer(stringRedisSerializer);
        return redisTemplate;
    }

}
</code></pre><p>@Cachable, @CacheEvict使用，Redis中的存储结构可参见场景2中的配图：</p>
<pre><code>@Cacheable(value=&quot;signonCache&quot;, key=&quot;&apos;petstore:signon:&apos;+#username&quot;, unless=&quot;#result==null&quot;)
public Signon findByName(String username) {
    return dao.fetchOneByUsername(username);
}

@CacheEvict(value=&quot;signonCache&quot;, key=&quot;&apos;petstore:signon:&apos;+#user.username&quot;)
public void update(Signon user) {
    dao.update(user);
}
</code></pre><ul>
<li>@Cacheable: 插入缓存<ul>
<li>value: 缓存名称</li>
<li>key: 缓存键，一般包含被缓存对象的主键，支持Spring EL表达式</li>
<li>unless: 只有当查询结果不为空时，才放入缓存</li>
</ul>
</li>
<li>@CacheEvict: 失效缓存</li>
</ul>
<blockquote>
<p>Tip: Spring Redis默认使用JDK进行序列化和反序列化，因此被缓存对象需要实现java.io.Serializable接口，否则缓存出错。</p>
<p>Tip: 当被缓存对象发生改变时，可以选择更新缓存或者失效缓存，但一般而言，后者优于前者，因为执行速度更快。</p>
<p>Watchout! 在同一个Class内部调用带有缓存注解的方法，缓存并不会生效。</p>
</blockquote>
<h2 id="场景2：共享Session"><a href="#场景2：共享Session" class="headerlink" title="场景2：共享Session"></a>场景2：共享Session</h2><p>共享Session是第二个典型应用场景，这是利用了Redis的堆外内存特性。要保证分布式应用的可伸缩性，带状态的Session对象是绕不过去的一道坎。一种方式是将Session持久化到数据库中，缺点是读写成本太高。另一种方式是去Session化，比如Play直接将Session存到客户端的Cookie中，缺点是存储信息的大小受限。将Session缓存到Redis中，既保证了可伸缩性，同时又避免了前面两者的限制。</p>
<p>引入依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>Session配置：</p>
<pre><code>@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400)
public class SessionConfig {
}
</code></pre><ul>
<li>maxInactiveIntervalInSeconds: 设置Session失效时间，使用Redis Session之后，原Boot的server.session.timeout属性不再生效</li>
</ul>
<p>Redis中的session对象：</p>
<p><img src="QQ20160313-0.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面结合示例代码介绍了数据缓存，共享Session两个Redis的典型应用场景，除此之外，还有分布式锁，全局计数器等高级应用场景，以后在其他文章中再详细介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://docs.spring.io/spring-data/redis/docs/current/reference/html/" target="_blank" rel="external">Spring Data Redis</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="external">Spring Cache抽象详解</a></li>
<li><a href="http://docs.spring.io/spring-session/docs/current/reference/html5/#httpsession-redis" target="_blank" rel="external">HttpSession with Redis</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】关于Boot应用中集成Spring Security你必须了解的那些事]]></title>
      <url>http://emacoo.cn/backend/spring-boot-security/</url>
      <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>Spring Security是Spring社区的一个顶级项目，也是Spring Boot官方推荐使用的Security框架。除了常规的Authentication和Authorization之外，Spring Security还提供了诸如ACLs，LDAP，JAAS，CAS等高级特性以满足复杂场景下的安全需求。虽然功能强大，Spring Security的配置并不算复杂（得益于官方详尽的文档），尤其在3.2版本加入Java Configuration的支持之后，可以彻底告别令不少初学者望而却步的XML Configuration。在使用层面，Spring Security提供了多种方式进行业务集成，包括注解，Servlet API，JSP Tag，系统API等。下面就结合一些示例代码介绍Boot应用中集成Spring Security的几个关键点。</p>
<h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1 核心概念"></a>1 核心概念</h3><p>Principle(User), Authority(Role)和Permission是Spring Security的3个核心概念。跟通常理解上Role和Permission之间一对多的关系不同，在Spring Security中，Authority和Permission是两个完全独立的概念，两者并没有必然的联系，但可以通过配置进行关联。</p>
<h3 id="2-基础配置"><a href="#2-基础配置" class="headerlink" title="2 基础配置"></a>2 基础配置</h3><p>首先在项目的pom.xml中引入spring-boot-starter-security依赖。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>和其余Spring框架一样，XML Configuration和Java Configuration是Spring Security的两种常用配置方式。Spring 3.2版本之后，Java Configuration因其流式API支持，强类型校验等特性，逐渐替代XML Configuration成为更广泛的配置方式。下面是一个示例Java Configuration。</p>
<pre><code>@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    MyUserDetailsService detailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .and().formLogin().loginPage(&quot;/login&quot;).permitAll().defaultSuccessUrl(&quot;/&quot;, true)
                .and().logout().logoutUrl(&quot;/logout&quot;)
                .and().sessionManagement().maximumSessions(1).expiredUrl(&quot;/expired&quot;)
                .and()
                .and().exceptionHandling().accessDeniedPage(&quot;/accessDenied&quot;);
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;, &quot;/images/**&quot;, &quot;/**/favicon.ico&quot;);
    }

    @Override
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(detailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

}
</code></pre><ul>
<li>@EnableWebSecurity: 禁用Boot的默认Security配置，配合@Configuration启用自定义配置（需要扩展WebSecurityConfigurerAdapter）</li>
<li>@EnableGlobalMethodSecurity(prePostEnabled = true): 启用Security注解，例如最常用的@PreAuthorize</li>
<li>configure(HttpSecurity): Request层面的配置，对应XML Configuration中的<code>&lt;http&gt;</code>元素</li>
<li>configure(WebSecurity): Web层面的配置，一般用来配置无需安全检查的路径</li>
<li>configure(AuthenticationManagerBuilder): 身份验证配置，用于注入自定义身份验证Bean和密码校验规则</li>
</ul>
<h3 id="3-扩展配置"><a href="#3-扩展配置" class="headerlink" title="3 扩展配置"></a>3 扩展配置</h3><p>完成基础配置之后，下一步就是实现自己的UserDetailsService和PermissionEvaluator，分别用于自定义Principle, Authority和Permission。</p>
<pre><code>@Component
public class MyUserDetailsService implements UserDetailsService {

    @Autowired
    private LoginService loginService;

    @Autowired
    private RoleService roleService;

    @Override
    public UserDetails loadUserByUsername(String username) {
        if (StringUtils.isBlank(username)) {
            throw new UsernameNotFoundException(&quot;用户名为空&quot;);
        }

        Login login = loginService.findByUsername(username).orElseThrow(() -&gt; new UsernameNotFoundException(&quot;用户不存在&quot;));

        Set&lt;GrantedAuthority&gt; authorities = new HashSet&lt;&gt;();
        roleService.getRoles(login.getId()).forEach(r -&gt; authorities.add(new SimpleGrantedAuthority(r.getName())));

        return new org.springframework.security.core.userdetails.User(
                username, login.getPassword(),
                true,//是否可用
                true,//是否过期
                true,//证书不过期为true
                true,//账户未锁定为true
                authorities);
    }
}
</code></pre><blockquote>
<p>创建GrantedAuthority对象时，一般名称加上ROLE_前缀。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class MyPermissionEvaluator implements PermissionEvaluator &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private LoginService loginService;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private RoleService roleService;</div><div class="line"></div><div class="line">	@Override</div><div class="line">   	public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) &#123;</div><div class="line">           String username = authentication.getName();</div><div class="line">           Login login = loginService.findByUsername(username).get();</div><div class="line">           return roleService.authorized(login.getId(), targetDomainObject.toString(), permission.toString());</div><div class="line">   	&#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">   	public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) &#123;</div><div class="line">	    // not supported</div><div class="line">    	return false;</div><div class="line">   	&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>hasPermission(Authentication, Object, Object)和hasPermission(Authentication, Serializable, String, Object)两个方法分别对应Spring Security中两个同名的表达式。</li>
</ul>
<h3 id="4-业务集成"><a href="#4-业务集成" class="headerlink" title="4 业务集成"></a>4 业务集成</h3><p>Spring Security提供了注解，Servlet API，JSP Tag，系统API等多种方式进行集成，最常用的是第一种方式，包含@Secured, @PreAuthorize, @PreFilter, @PostAuthorize和@PostFilter五个注解。@Secure是最初版本中的一个注解，自3.0版本引入了支持Spring EL表达式的其余四个注解之后，就很少使用了。</p>
<pre><code>@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)
@PreAuthorize(&quot;authenticated and hasPermission(&apos;hello&apos;, &apos;view&apos;)&quot;)
public String hello(Model model) {
    String username = SecurityContextHolder.getContext().getAuthentication().getName();
    model.addAttribute(&quot;message&quot;, username);
    return &quot;hello&quot;;
}
</code></pre><ul>
<li>@PreAuthorize(“authenticated and hasPermission(‘hello’, ‘view’)”): 表示只有当前已登录的并且拥有(“hello”, “view”)权限的用户才能访问此页面</li>
<li>SecurityContextHolder.getContext().getAuthentication().getName(): 获取当前登录的用户，也可以通过HttpServletRequest.getRemoteUser()获取</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Spring Security的一般集成步骤，更多细节和高级特性可参考官方文档。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/</a></li>
<li><a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/" target="_blank" rel="external">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Spring】如何在单个Boot应用中配置多数据库？]]></title>
      <url>http://emacoo.cn/backend/spring-boot-multi-db/</url>
      <content type="html"><![CDATA[<h2 id="为什么需要多数据库？"><a href="#为什么需要多数据库？" class="headerlink" title="为什么需要多数据库？"></a>为什么需要多数据库？</h2><p>默认情况下，Spring Boot使用的是单数据库配置（通过spring.datasource.*配置具体数据库连接信息）。对于绝大多数Spring Boot应用，这是符合其使用场景的，因为Spring Boot提倡的是微服务理念，每个应用对应一个单独的业务领域。但在某些特殊情况下，一个应用对应多个数据库又是无法避免的，例如实施数据库分库后原本单个数据库变为多个数据库。本文就结合实际代码介绍如何在单个Boot应用中配置多数据库，以及与之相关的Druid，jOOQ，Flyway等数据服务框架的配置改造。</p>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p><img src="QQ20160221-0.png" alt=""></p>
<ul>
<li>DB1，DB2: 两个示例数据库</li>
<li>ServiceA, ServiceB: 分别使用DB1和DB2的服务类</li>
</ul>
<h3 id="连接池Druid"><a href="#连接池Druid" class="headerlink" title="连接池Druid"></a>连接池Druid</h3><p><a href="https://github.com/alibaba/druid" target="_blank" rel="external">Druid</a>是阿里巴巴开源的数据库连接池，提供了强大的监控支持，号称Java语言中最好的连接池。</p>
<p>创建两个配置类分别注册对应DB1和DB2的DataSource Bean和TransactionManager Bean。以DB1为例：</p>
<blockquote>
<p>Tip: 可以把其中一个配置类中注册的DataSource Bean和DataSourceTransactionManager Bean加上@Primary注解，作为默认装配实例。</p>
</blockquote>
<pre><code>// DB1
@Configuration
public class Db1Config {

    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;close&quot;)
    @ConfigurationProperties(prefix = &quot;db.db1&quot;)
    public DataSource dataSource1() {
        return new DruidDataSource();
    }

    @Bean
    public DataSourceTransactionManager transactionManager1() {
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource1());
        return transactionManager;
    }
}
</code></pre><p>application.conf中的配置：</p>
<pre><code># DB1
db.db1.url=jdbc:mysql://127.0.0.1:3306/db1?useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true
db.db1.username=root
db.db1.password=
</code></pre><h3 id="ORM框架jOOQ"><a href="#ORM框架jOOQ" class="headerlink" title="ORM框架jOOQ"></a>ORM框架jOOQ</h3><p><a href="http://www.jooq.org/" target="_blank" rel="external">jOOQ</a>是一个开源ORM框架，最大特点是提供类型安全的流式API，支持代码生成。</p>
<p>参照Boot自带的JooqAutoConfiguration，不难写出如下配置类：</p>
<pre><code>@Configuration
public class JooqConfig {

    // DB1
    @Bean
    public DataSourceConnectionProvider dataSourceConnectionProvider1(
            @Qualifier(&quot;dataSource1&quot;) DataSource dataSource1) {
        return new DataSourceConnectionProvider(
                new TransactionAwareDataSourceProxy(dataSource1));
    }

    @Bean
    public SpringTransactionProvider transactionProvider1(
            @Qualifier(&quot;transactionManager1&quot;) DataSourceTransactionManager txManager1) {
        return new SpringTransactionProvider(txManager1);
    }

    // DB2
    // ...

    @Configuration
    public static class DslContextConfig {

        @Autowired(required = false)
        private RecordMapperProvider recordMapperProvider;

        @Autowired(required = false)
        private Settings settings;

        @Autowired(required = false)
        private RecordListenerProvider[] recordListenerProviders;

        @Autowired
        private ExecuteListenerProvider[] executeListenerProviders;

        @Autowired(required = false)
        private VisitListenerProvider[] visitListenerProviders;

        // DSLContext for DB1
        @Bean
        public DefaultDSLContext dslContext1(@Qualifier(&quot;dataSourceConnectionProvider1&quot;) DataSourceConnectionProvider connectionProvider1,
                                            @Qualifier(&quot;transactionProvider1&quot;) SpringTransactionProvider transactionProvider1) {
            return new DefaultDSLContext(configuration(connectionProvider1, transactionProvider1));
        }

        // DSLContext for DB2
        // ...

        private DefaultConfiguration configuration(ConnectionProvider connectionProvider, TransactionProvider transactionProvider) {
            DefaultConfiguration configuration = new DefaultConfiguration();
            configuration.setSQLDialect(SQLDialect.MYSQL);
            configuration.set(connectionProvider);
            configuration.set(transactionProvider);
            if (this.recordMapperProvider != null) {
                configuration.set(this.recordMapperProvider);
            }
            if (this.settings != null) {
                configuration.set(this.settings);
            }
            configuration.set(this.recordListenerProviders);
            configuration.set(this.executeListenerProviders);
            configuration.set(this.visitListenerProviders);
            return configuration;
        }
    }
}
</code></pre><h3 id="服务类"><a href="#服务类" class="headerlink" title="服务类"></a>服务类</h3><p>配置好DataSource，TransacationManager和DSLContext之后，服务类的配置就比较简单了，直接引用即可。注意由于存在多套Beans，需要通过@Qualifier注解指定装配实例。</p>
<pre><code>@Transactional(&quot;TransactionManager1&quot;)
public class ServiceA {

    @Autowired
    @Qualifier(&quot;dslContext1&quot;)
    protected DSLContext dsl;
}
</code></pre><h3 id="数据库迁移框架Flyway"><a href="#数据库迁移框架Flyway" class="headerlink" title="数据库迁移框架Flyway"></a>数据库迁移框架Flyway</h3><p><a href="https://flywaydb.org/" target="_blank" rel="external">Flyway</a>是一个轻量级的开源数据库迁移框架，使用非常广泛。</p>
<p>参照Boot自带的FlywayAutoConfiguration，同样可以写出如下配置类：</p>
<pre><code>@Configuration
public class FlywayConfig {

    @Bean(initMethod = &quot;migrate&quot;)
    @ConfigurationProperties(prefix = &quot;fw.db1&quot;)
    public Flyway flyway(@Qualifier(&quot;dataSource1&quot;) DataSource dataSource1) {
        Flyway clinic = new Flyway();
        clinic.setDataSource(dataSource1);
        return clinic;
    }

    // DB2
    // ...

    /**
     * @see FlywayAutoConfiguration
     */
    @Bean
    @ConfigurationPropertiesBinding
    public StringOrNumberToMigrationVersionConverter stringOrNumberMigrationVersionConverter() {
        return new StringOrNumberToMigrationVersionConverter();
    }

    /**
     * Convert a String or Number to a {@link MigrationVersion}.
     * @see FlywayAutoConfiguration
     */
    private static class StringOrNumberToMigrationVersionConverter
            implements GenericConverter {

        private static final Set&lt;ConvertiblePair&gt; CONVERTIBLE_TYPES;

        static {
            Set&lt;ConvertiblePair&gt; types = new HashSet&lt;ConvertiblePair&gt;(2);
            types.add(new ConvertiblePair(String.class, MigrationVersion.class));
            types.add(new ConvertiblePair(Number.class, MigrationVersion.class));
            CONVERTIBLE_TYPES = Collections.unmodifiableSet(types);
        }

        @Override
        public Set&lt;ConvertiblePair&gt; getConvertibleTypes() {
            return CONVERTIBLE_TYPES;
        }

        @Override
        public Object convert(Object source, TypeDescriptor sourceType,
                              TypeDescriptor targetType) {
            String value = ObjectUtils.nullSafeToString(source);
            return MigrationVersion.fromVersion(value);
        }

    }
}
</code></pre><p>application.conf中的配置：</p>
<pre><code># DB1
fw.db1.enabled=true
</code></pre><h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>有经验的同学马上会问，多数据库下事务会不会有问题？需要改造成分布式事务吗？只要为每个数据库创建独立的TransactionManager，就不会有问题，Spring会自动处理好事务的提交和回滚，就像单数据库一样。至于分布式事务，大可不必，因为虽然有多个数据库，但仍然属于Local Transaction范畴。以后有时间我会再写篇文章展开阐述一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由上可见，无论是基础的DataSource和TransactionManager，还是Spring之外的第三方框架，在Boot中基本都可以找到相应的AutoConfiguration配置类。参照这些配置类，就不难根据实际需要写出自己的扩展版本。对于那些找不到AutoConfiguration配置类的，可结合框架的官方文档，使用@Configuration和@Bean注解自行进行配置。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【翻译】Scala的起源 —— Martin Odersky访谈（一）]]></title>
      <url>http://emacoo.cn/coding/scala-origins/</url>
      <content type="html"><![CDATA[<p>Scala是一种运行在JVM之上的通用的，面向对象的函数式语言。它的作者是Martin Odersky，一位来自洛桑联邦理工大学（EPFL）的教授。作为本系列访谈的第一部分，Martin Odersky和Artima网站的Bill Venners一起讨论了Scala的历史和起源。</p>
<h2 id="结缘编译器"><a href="#结缘编译器" class="headerlink" title="结缘编译器"></a>结缘编译器</h2><p><strong>Bill Venners</strong>: 让我们回到最初。你是如何接触编程语言的？</p>
<blockquote>
<p><strong>Martin Odersky</strong>: 编译器和编程语言从来都是我最爱的课题。1980年，那时我还在读本科，当我第一次搞明白什么是编译器，我立刻就想自己构建一个。我当时唯一能买的起的电脑就是拥有1K内存的Sinclair ZX 80。我差点就能一试身手，不过幸运的是，很快我接触到一台更强大的电脑，Osborne-1。它是世界上第一台便携式电脑，从远处看起来就像一台倾斜了90度的缝纫机。它拥有5英寸屏幕，每行显示52个字符。最令人印象深刻的是它拥有56K内存以及两个90K的软盘驱动器。</p>
<p>那段时间，我经常和学校里一名叫Peter Sollich的学生在一起。我们通过阅读了解到一门新的被称为Modula-2的语言，我们发现这门语言不仅非常优雅而且设计也很棒。于是我们就产生了为8位的Z80电脑设计Modula-2编译器的念头。不过Osborne有一个小问题，它只自带微软Basic这一门语言。这跟我们的预想完全不相符，因为Basic语言只支持全局变量，甚至不支持带参数的过程。而当时其它的编译器对我们而言都太贵了。于是我们决定采用经典的引导技术（bootstrapping technique）。Peter曾经用Z80的汇编语言写过一个支持部分Pascal语法的编译器。我们使用这个编译器编译了更大一点的语言，然后再更大一点，迭代数次后，直至我们能够编译所有Modula-2的语法。这个新的编译器能够生成用于解释执行的字节码以及相应的Z80上的二进制文件。这些字节码是当时任何系统上所能生成的最紧凑的字节码，相应的二进制版本也是8位电脑上运行最快的。这个编译器在当时可以说是相当棒的。</p>
<p>就在我们快完成我们的编译器时，Borland推出了Turbo Pascal，并且准备进军Modula-2市场。实际上，Borland决定购买我们的Modula-2编译器，重新冠以Turbo Module-2（CP/M版本）的名称和另一款他们打算开发的IBM PC版本一起搭售。我们提出为他们开发这个IBM PC版本，但是他们告诉我们他们已经有人在着手做了。三或四年之后，当这款编译器最终面世时，实现它的团队已经从Borland分离出来，并且为这款编译器起了一个新的名字，TopSpeed Module-2。在缺少IBM PC版本的情况下，Borland从来没有进行过任何Turbo Modula-2的市场推广，因此它也一直默默无名。</p>
<p>当我们完成Modula-2编译器时，Borland立刻提出聘请Peter和我。Peter加入了他们。我差点也去了，但是我还有一年的课程以及研究生计划。我当时对从大学辍学的念头也很动心。最后，我还是决定留在学校。在我读研期间（研究课题是增量解析），我发现我非常喜欢做研究。所以最终，我放弃了去Borland写编译器的念头，转而去ETH Zurich跟随Pascal和Module-2的发明者Niklaus Wirth攻读博士学位。</p>
</blockquote>
<h2 id="更好的Java"><a href="#更好的Java" class="headerlink" title="更好的Java"></a>更好的Java</h2><p><strong>Bill Venners</strong>: Scala是如何产生的？它的历史是什么样的？</p>
<blockquote>
<p><strong>Martin Odersky</strong>: 1988、1989年之间，当我即将结束在Zurich的学业，我对函数式编程产生了极大的兴趣。所以我留下来继续做研究，最后成为了德国Karlsruhe大学的一名教授。一开始我专注于偏理论的编程领域，比如按需调用（call-by-need）的λ演算。这部分工作是和当时在Glasgow大学的Phil Wadler一起进行的。一天，Phil告诉我他组里的一个助教听说有一门新的语言正在兴起，目前处于Alpha版本，名字叫Java。它是可迁移的，能够产生字节码，运行在web端，并且有垃圾回收机制。这门语言将颠覆你的工作。你准备怎么办？Phil说。好吧，他也许是对的。</p>
<p>回答是Phil Wadler和我决定将一部分函数式编程的概念植入到Java世界中。这部分工作诞生了一门叫Pizza的语言，它拥有3个函数式编程的特性，泛型，高阶函数和模式匹配。Pizza首次发布于1996年，在Java面世后的一年。它成功的证明了在JVM平台上是能够实现函数式语言特性的。</p>
<p>于是我们联系了Sun公司核心开发团队的Gilad Bracha和David Stoutamire。他们回应说，“我们对你们正在做的泛型那部分工作很感兴趣。我们可以开始一个新的专注于此的项目。”那个项目被称为GJ（Generic Java）。1997、1998年之间，我们完成了GJ的开发。六年后，加上一些之前我们没做的特性，它成为了Java 5中的泛型。值得一提的是，Java泛型中的通配符是在我们之后由Gilad Bracha和Aarhus大学的其他人一起独立完成的。</p>
<p>虽然我们的泛型扩展延期了六年才推出，Sun对我写的GJ编译器产生了更强烈的兴趣。它被证明比Sun最初版本的Java编译器更稳定也更易维护。所以他们决定从2000年发布的Java 1.3版本起，使用GJ编译器作为标准的Java编译器。</p>
</blockquote>
<h2 id="超越Java"><a href="#超越Java" class="headerlink" title="超越Java"></a>超越Java</h2><blockquote>
<p><strong>Martin Odersky</strong>: 在开发Pizza和GJ期间，我有时感到绝望，因为Java是一门限制性很强的语言，很多事情不能按我自认为正确的方式去做。因此，在那之后，当我实质性的工作目标转移到让Java更好上时，我决定是时候后退一步了。我想从头来过，看看我能否设计出一门比Java更好的语言。但同时我知道我不能从零开始，我必须借助于已有的基础架构，没有任何类库、工具的支持去启动这样一个项目是不现实的。所以我决定虽然我的目的是设计一门与Java不同的语言，但这门语言仍然可以与Java的基础架构（JVM和类库）互连。这就是我（设计Scala语言）的初衷。也是在那个时候，我成为了EPFL的一名教授，这为我提供了一个绝佳的进行独立研究的环境。我得以成立一个研究小组，无需成天申请外部津贴。</p>
<p>起初我们非常激进。我们想创建一门基于一个被称为join calculus的非常完美的并发模型上的语言。我们创建了一个被称为Functional Nets的面向对象版本的join calculus实现，以及一门基于其上的语言Funnal。但没过多久，我们发现作为一门很纯粹的语言，Funnel并没有太多实际意义。Funnal有一个很小的内核。很多大家认为理所应当包含的东西（比如类，模式匹配）只能通过编码的方式植入到内核中。从学术的角度，这是一种很优雅的技巧。但从实践角度，并不是太好。初学者发现这类编码非常困难，而专家们又认为过于重复和单调。</p>
<p>结果是我们决定重新开始，在非常纯粹的学术性语言Funnal和非常实用但又在一定程度上带有限制性的GJ之间寻找出路。我们想创造一门不仅实用同时又比Java更高级的语言。大约在2002年，我们开始开发这门后来被我们称为Scala的语言，并于2003年发布第一版本。2006年初，又发布了一个相对比较大的重构版本。在此之后，就进入一个稳定的迭代期。</p>
</blockquote>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p><strong>Bill Venners</strong>: 你曾说有时候为了保证与Java的兼容性让你非常抓狂。你能给一些具体的起初由于兼容性限制你做不了，但后来从源代码兼容性降为二进制兼容性之后又可以做的例子吗？</p>
<blockquote>
<p><strong>Martin Odersky</strong>: 在泛型设计中，存在很多非常非常困难的限制。最强的也是最难解决的限制是需要与没有泛型支持的Java版本兼容。这个问题的背景是Java 1.2版本发布了没有泛型支持的集合类库，那时泛型刚出现，Sun公司还没准备好发布一个全新的基于泛型的集合类库。</p>
<p>那就是为什么存在这么多非常丑陋的设计的原因。你总是要同时面对非泛型类型和泛型类型（也被成为原始类型）。同样你也不能改变数组的行为，于是你就不得不接受未受检警告。最重要的是，在操作数组时很多你想做的事情是做不了的，比如生成一个拥有未知类型T的数组。后来在Scala中我们实际上发现了一种实现的方式，但那是由于我们给数组加入了协变的特性。</p>
</blockquote>
<p><strong>Bill Venners</strong>: 你能够详细说明一下有关Java中协变数组的问题吗？</p>
<blockquote>
<p><strong>Martin Odersky</strong>: 最初Java刚发布时，Bill Joy和James Gosling以及其他Java组成员都认为Java应该支持泛型，只是他们没有时间去完善设计并加入进去。正因为最初版本的Java不支持泛型，他们感觉数组应该是协变的。举例来说，那就意味着一个String数组是一个Object数组的子类型。背后的原因是他们想实现一个类泛型的排序方法，接受一个Object数组和一个排序类然后对这个数组进行排序，同时允许你传入一个String数组。结果发现这个设计通常是有缺陷的。那就是为什么在Java中你会得到一个数组存储异常。实际上这个设计最后也阻止了实现一个优雅的泛型数组。那就是为什么Java泛型中根本不支持数组。你不能创建一个类型为String列表的数组，这根本不可能。你永远不得不使用丑陋的原始类型，一个列表类型的数组。所以某种程度上这就是一个原罪。他们完成的很快，认为这只不过是一次快速改造。但实际上这毁掉了之后每一个设计决定。因此，为了避免掉入同样的陷阱，我们不得不停下来宣布，现在我们不再和Java保持向前兼容，我们想做一些不同的事。</p>
</blockquote>
<p><em>查看英文原文：<a href="http://www.artima.com/scalazine/articles/origins_of_scala.html" target="_blank" rel="external">The Origins of Scala</a></em></p>
<p>该系列访谈的其余部分：</p>
<ul>
<li><a href="http://www.infoq.com/cn/articles/Scala-Design" target="_blank" rel="external">Scala的设计目标——Martin Odersky访谈（二）</a></li>
<li><a href="http://www.infoq.com/cn/articles/scala-type-system" target="_blank" rel="external">Scala类型系统的目的——Martin Odersky访谈（三）</a></li>
<li><a href="http://www.infoq.com/cn/articles/Scala-PatternMatching" target="_blank" rel="external">Scala模式匹配的亮点——Martin Odersky访谈（四）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Web】CDN加速效果浅析]]></title>
      <url>http://emacoo.cn/arch/web-cdn-benchmark/</url>
      <content type="html"><![CDATA[<h2 id="1-什么是CDN？"><a href="#1-什么是CDN？" class="headerlink" title="1. 什么是CDN？"></a>1. 什么是CDN？</h2><blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘”的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<br><a href="http://www.51know.info/system_performance/cdn/cdn.html" target="_blank" rel="external">http://www.51know.info/system_performance/cdn/cdn.html</a></p>
</blockquote>
<p>可以认为，CDN就是加上了智能DNS和缓存层的反向代理集群。由于智能DNS能够根据请求的来源定位到离用户较近的缓存服务器，因此有效的缩短了连接时间，而缓存层的存在极大的提高了下载速度，并且不再受限于源站的带宽大小。注意上述第二点仅针对静态资源有意义，对于动态内容（比如POST请求，WebSocket连接），CDN仍然需要将请求发回源站再将结果返回，并不能起到加速作用。下面就针对上述分析进行实验验证。</p>
<h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><ul>
<li>源站，提供静态页面和WebSocket服务。</li>
<li>CDN，使用腾讯云CDN服务，仅对静态页面设置缓存。</li>
</ul>
<h2 id="3-基准测试"><a href="#3-基准测试" class="headerlink" title="3. 基准测试"></a>3. 基准测试</h2><h3 id="3-1-静态页面"><a href="#3-1-静态页面" class="headerlink" title="3.1 静态页面"></a>3.1 静态页面</h3><p>如下图所示，使用CDN之后，无论是连接时间还是下载时间都明显缩短，下载速度也有<strong>5倍</strong>以上的提速。</p>
<p><img src="web-cdn-benchmark-static.png" alt=""></p>
<p>测速网站：<a href="http://www.17ce.com/" target="_blank" rel="external">http://www.17ce.com/</a></p>
<h3 id="3-2-动态内容"><a href="#3-2-动态内容" class="headerlink" title="3.2 动态内容"></a>3.2 动态内容</h3><p>选择一台远离源站的服务器，运行Node基准测试，先后与源站和CDN站建立WebSocket连接，发送消息，计算总耗时。测试结果显示，与直连源站相比，使用CDN并没有起到加速效果，反而有所下降。不难理解，这是因为去掉缓存之后，CDN平白在用户和源站之间多加了一层链路。</p>
<p><img src="web-cdn-benchmark-ws.png" alt=""></p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li><a href="http://www.51know.info/system_performance/cdn/cdn.html" target="_blank" rel="external">http://www.51know.info/system_performance/cdn/cdn.html</a></li>
<li><a href="http://www.qcloud.com/wiki/CDN%E4%BB%8B%E7%BB%8D" target="_blank" rel="external">http://www.qcloud.com/wiki/CDN%E4%BB%8B%E7%BB%8D</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[既然选择了远方，就只顾风雨兼程]]></title>
      <url>http://emacoo.cn/notes/xr-ruijin/</url>
      <content type="html"><![CDATA[<p>周六，早上8:30，这个城市大多数年轻人仍在温暖的被窝里，XR上海23名顾问已准时集结在大会议室，待早会之后便奔赴各自的“战场”。早会里面绩效评比这个环节很有特色，顾问的四项核心绩效指标（活跃数，拜访量，日报，医院照片）分别被比喻成早、中、晚饭加夜宵，让枯燥的数字变得充满关怀。</p>
<p>小何，上海顾问团队第三组小组长，和两位战狼配合打瑞金医院，是我今天的跟访对象。薄夹克，公文包，显得很利落。我问他冷不冷，他说不冷，一天医院跑下来，常常一身汗，不能穿太多。去医院的路上，小何主动跟我聊了一些移动医疗的话题，虽然10月份刚从一家传统的面向企业的软件公司跳槽到我们公司，但他对于互联网和医疗行业已经非常熟悉，对公司的产品和理念也非常认同。</p>
<p>到了医院，我们先在门诊大楼跟战狼小张会合，然后坐电梯上19楼住院部。昨天小张在那里拿下了一批新的认证医生，今天过去发放台卡。因为是周六，医生办公室里只有一个女医生，见了小何和小张显得很客气。小张发放台卡的时候，我才注意到他除了一个背包，肩上还跨了一个背袋，里面装满了台卡，大概有十个左右。我们的台卡除了纸质日历本，还配有一个木头底座和一块木板，不难想象这一袋台卡着实是有些分量的。一天背下来，也是件体力活。Hunter说去年打北京的时候，20吨礼品生生的被战狼们背进了各家医院，真不是玩笑话。</p>
<p>在医院做地推其实就是门诊室蹲点和住院部扫楼。像瑞金这样的知名三甲医院，患者多医生多楼也多，大医生们神出鬼没，除了门诊，其他地方难见踪影。而门诊一般都是人满为患，一天中最有效的时间只有中午11点到12点，下午4点到5点这两个小时，战狼和顾问们需要争分夺秒，逐个敲开没人排队的门诊室，给医生们介绍我们的产品和帮助他们掌握基本的操作。一般的流程是，头天战狼帮医生安装好App，第二天顾问上门教会医生使用App。在这之后，顾问会有节奏的持续拜访这些医生，从中筛选出最有可能成为高活跃的医生并提供更有针对性的服务。</p>
<p>出了门诊大楼，小何带我扫了一遍12层的6号楼，那里是瑞金的一个住院部。坐电梯到12楼，然后逐层往下，每一层有两个医生办公室。临近中午，加上又是周末，办公室都很冷清，一般1到2位，半数都空着。医生们或者在操作电脑，或者在休息，或者在跟患者聊天，这些医生顾问都不会去打扰，他们会找那些正在闲聊或者刷手机的医生。好不容易找到一个，小何赶紧凑上去，三言两句就顺利的拿到那名医生的手机开始过权威认证，演示加患者流程，告之如何开通收费服务等。一圈聊完，我看了一下时钟大概花了10分钟左右。“她成不了高活跃医生。”出了办公室，小何摇了摇头。</p>
<p>扫完6号楼已经过了12点，小何请我在瑞金食堂吃了午饭。“下午要抓紧了，不然一天又过去了。”小何对自己说，又像是对我说。是啊，要抓紧了，在通往梦想的路上，每一天都蕴含着无限的可能。</p>
<p>既然选择了远方，就只顾风雨兼程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【Play】热部署是如何工作的？]]></title>
      <url>http://emacoo.cn/backend/play-hotdeploy/</url>
      <content type="html"><![CDATA[<h2 id="1-什么是热部署"><a href="#1-什么是热部署" class="headerlink" title="1.什么是热部署"></a>1.什么是热部署</h2><blockquote>
<p>所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。对于Java应用程序来说，热部署就是在运行时更新Java类文件。– <a href="http://baike.baidu.com/view/5036687.htm" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p>对于Java应用，有三种常见的实现热部署的方式：</p>
<ul>
<li>JPDA: 利用JVM原生的JPDA接口，参见<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/enhancements1.4.html#hotswap" target="_blank" rel="external">官方文档</a></li>
<li>Classloader: 通过创建新的Classloader来加载新的Class文件。OSGi就是通过这种方式实现Bundle的动态加载。</li>
<li>Agent: 通过自定义Java Agent实现Class动态加载。JRebel，hotswapagent使用的就是这种方式。</li>
</ul>
<p>Play console自带的auto-reload功能正是基于上述第二种方式实现的。</p>
<h2 id="2-Auto-reload机制"><a href="#2-Auto-reload机制" class="headerlink" title="2.Auto-reload机制"></a>2.Auto-reload机制</h2><p>Play console是Typesafe封装的一种特殊的的sbt console，主要增加了activator new和activator ui两个命令。其auto-reload功能是以sbt插件（”com.typesafe.play” % “sbt-plugin”）的形式提供的，sbt-plugin通过sbt-run-support类库连接到play开发模式下的启动类（play.core.server.DevServerStart）。每当应用收到请求时，play会通过sbt-plugin检查是否有源文件被修改，如果存在，则调用sbt命令进行编译，然后依次停止老的play应用，创建新的classloader，然后启动新的play应用，在此过程中运行sbt的JVM并没有被重启，只是play应用完成了重启。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>以下分别从sbt-plugin,sbt-run-support和play-server挑选3个核心类对上述流程进行简单梳理。</p>
<h3 id="play-sbt-run-PlayRun"><a href="#play-sbt-run-PlayRun" class="headerlink" title="play.sbt.run.PlayRun"></a>play.sbt.run.PlayRun</h3><p>定义play run task，通过Reloader传递sbt回调函数引用给DevServerStart。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[<span class="type">Line</span> <span class="number">73</span><span class="number">-93</span>: <span class="type">PlayRun</span>#playRunTask]</div><div class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> devModeServer = <span class="type">Reloader</span>.startDevMode(</div><div class="line">      runHooks.value,</div><div class="line">      (javaOptions in <span class="type">Runtime</span>).value,</div><div class="line">      dependencyClasspath.value.files,</div><div class="line">      dependencyClassLoader.value,</div><div class="line">      reloadCompile,										# sbt回调函数引用</div><div class="line">      reloaderClassLoader.value,</div><div class="line">      assetsClassLoader.value,</div><div class="line">      playCommonClassloader.value,</div><div class="line">      playMonitoredFiles.value,</div><div class="line">      fileWatchService.value,</div><div class="line">      (managedClasspath in <span class="type">DocsApplication</span>).value.files,</div><div class="line">      playDocsJar.value,</div><div class="line">      playDefaultPort.value,</div><div class="line">      playDefaultAddress.value,</div><div class="line">      baseDirectory.value,</div><div class="line">      devSettings.value,</div><div class="line">      args,</div><div class="line">      runSbtTask,</div><div class="line">      (mainClass in (<span class="type">Compile</span>, <span class="type">Keys</span>.run)).value.get</div><div class="line">    )</div></pre></td></tr></table></figure>
<h3 id="play-runsupport-Reloader"><a href="#play-runsupport-Reloader" class="headerlink" title="play.runsupport.Reloader"></a>play.runsupport.Reloader</h3><p>通过反射启动play应用，将Reloader自身作为参数传入。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[<span class="type">Line</span> <span class="number">203</span><span class="number">-212</span>: <span class="type">Reloader</span>#startDevMode]</div><div class="line"><span class="keyword">val</span> server = &#123;</div><div class="line">    <span class="keyword">val</span> mainClass = applicationLoader.loadClass(mainClassName)</div><div class="line">    <span class="keyword">if</span> (httpPort.isDefined) &#123;</div><div class="line">        <span class="keyword">val</span> mainDev = mainClass.getMethod(<span class="string">"mainDevHttpMode"</span>, classOf[<span class="type">BuildLink</span>], classOf[<span class="type">BuildDocHandler</span>], classOf[<span class="type">Int</span>], classOf[<span class="type">String</span>])</div><div class="line">        mainDev.invoke(<span class="literal">null</span>, reloader, buildDocHandler, httpPort.get: java.lang.<span class="type">Integer</span>, httpAddress).asInstanceOf[play.core.server.<span class="type">ServerWithStop</span>]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">val</span> mainDev = mainClass.getMethod(<span class="string">"mainDevOnlyHttpsMode"</span>, classOf[<span class="type">BuildLink</span>], classOf[<span class="type">BuildDocHandler</span>], classOf[<span class="type">Int</span>], classOf[<span class="type">String</span>])</div><div class="line">        mainDev.invoke(<span class="literal">null</span>, reloader, buildDocHandler, httpsPort.get: java.lang.<span class="type">Integer</span>, httpAddress).asInstanceOf[play.core.server.<span class="type">ServerWithStop</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="play-core-server-DevServerStart"><a href="#play-core-server-DevServerStart" class="headerlink" title="play.core.server.DevServerStart"></a>play.core.server.DevServerStart</h3><p>从注释可以清楚的看到stop-and-start的重启逻辑。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">[<span class="type">Line</span> <span class="number">113</span><span class="number">-180</span>: <span class="type">DevServerStart</span>#mainDev]</div><div class="line"><span class="keyword">val</span> reloaded = buildLink.reload <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">NonFatal</span>(t) =&gt; <span class="type">Failure</span>(t)</div><div class="line">    <span class="keyword">case</span> cl:</div><div class="line">        <span class="type">ClassLoader</span> =&gt; <span class="type">Success</span>(<span class="type">Some</span>(cl))</div><div class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="type">Success</span>(<span class="type">None</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">reloaded.flatMap &#123;</div><div class="line">    maybeClassLoader =&gt;</div><div class="line"></div><div class="line">        <span class="keyword">val</span> maybeApplication: <span class="type">Option</span>[<span class="type">Try</span>[<span class="type">Application</span>]] = maybeClassLoader.map &#123;</div><div class="line">            projectClassloader =&gt;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (lastState.isSuccess) &#123;</div><div class="line">                        println()</div><div class="line">                        println(play.utils.<span class="type">Colors</span>.magenta(<span class="string">"--- (RELOAD) ---"</span>))</div><div class="line">                        println()</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">val</span> reloadable = <span class="keyword">this</span></div><div class="line"></div><div class="line">                    <span class="comment">// First, stop the old application if it exists</span></div><div class="line">                    lastState.foreach(<span class="type">Play</span>.stop)</div><div class="line"></div><div class="line">                    <span class="comment">// Create the new environment</span></div><div class="line">                    <span class="keyword">val</span> environment = <span class="type">Environment</span>(path, projectClassloader, <span class="type">Mode</span>.<span class="type">Dev</span>)</div><div class="line">                    <span class="keyword">val</span> sourceMapper = <span class="keyword">new</span> <span class="type">SourceMapper</span> &#123;</div><div class="line">                        <span class="function"><span class="keyword">def</span> <span class="title">sourceOf</span></span>(className: <span class="type">String</span>, line: <span class="type">Option</span>[<span class="type">Int</span>]) = &#123;</div><div class="line">                            <span class="type">Option</span>(buildLink.findSource(className, line.map(_.asInstanceOf[java.lang.<span class="type">Integer</span>]).orNull)).flatMap &#123;</div><div class="line">                                <span class="keyword">case</span> <span class="type">Array</span>(file: java.io.<span class="type">File</span>, <span class="literal">null</span>) =&gt; <span class="type">Some</span>((file, <span class="type">None</span>))</div><div class="line">                                <span class="keyword">case</span> <span class="type">Array</span>(file: java.io.<span class="type">File</span>, line: java.lang.<span class="type">Integer</span>) =&gt; <span class="type">Some</span>((file, <span class="type">Some</span>(line)))</div><div class="line">                                <span class="keyword">case</span> _ =&gt; <span class="type">None</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">val</span> webCommands = <span class="keyword">new</span> <span class="type">DefaultWebCommands</span></div><div class="line">                    currentWebCommands = <span class="type">Some</span>(webCommands)</div><div class="line"></div><div class="line">                    <span class="keyword">val</span> newApplication = <span class="type">Threads</span>.withContextClassLoader(projectClassloader) &#123;</div><div class="line">                        <span class="keyword">val</span> context = <span class="type">ApplicationLoader</span>.createContext(environment, dirAndDevSettings, <span class="type">Some</span>(sourceMapper), webCommands)</div><div class="line">                        <span class="keyword">val</span> loader = <span class="type">ApplicationLoader</span>(context)</div><div class="line">                        loader.load(context)</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="type">Play</span>.start(newApplication)</div><div class="line"></div><div class="line">                    <span class="type">Success</span>(newApplication)</div><div class="line">                &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                    <span class="keyword">case</span> e:</div><div class="line">                        <span class="type">PlayException</span> =&gt; &#123;</div><div class="line">                            lastState = <span class="type">Failure</span>(e)</div><div class="line">                            lastState</div><div class="line">                        &#125;</div><div class="line">                    <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; &#123;</div><div class="line">                        lastState = <span class="type">Failure</span>(<span class="type">UnexpectedException</span>(unexpected = <span class="type">Some</span>(e)))</div><div class="line">                        lastState</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">case</span> e:</div><div class="line">                        <span class="type">LinkageError</span> =&gt; &#123;</div><div class="line">                            lastState = <span class="type">Failure</span>(<span class="type">UnexpectedException</span>(unexpected = <span class="type">Some</span>(e)))</div><div class="line">                            lastState</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    maybeApplication.flatMap(_.toOption).foreach &#123;</div><div class="line">        app =&gt;</div><div class="line">            lastState = <span class="type">Success</span>(app)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    maybeApplication.getOrElse(lastState)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-Gotcha"><a href="#4-Gotcha" class="headerlink" title="4. Gotcha"></a>4. Gotcha</h2><p>上述的实现看上去并不复杂，那为什么老牌的Tomcat，JBoss容器却始终没有提供类似的机制呢？原因很简单，Play是stateless的，而其余的不是。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://jto.github.io/articles/play_anatomy_part2_sbt/" target="_blank" rel="external">http://jto.github.io/articles/play_anatomy_part2_sbt/</a></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
